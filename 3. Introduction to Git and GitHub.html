<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3. Introduction to Git and GitHub</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#introduction-to-git-and-github">3. Introduction to Git and GitHub</a>
<ul>
<li><a href="#before-version-control">Before Version Control</a>
<ul>
<li><a href="#module-introduction">Module Introduction</a></li>
<li><a href="#keeping-historical-copies">Keeping Historical Copies</a></li>
<li><a href="#diffing-files">Diffing Files</a></li>
<li><a href="#applying-changes">Applying Changes</a></li>
<li><a href="#practical-application-of-diff-and-patch">Practical Application of diff and patch</a></li>
</ul>
</li>
<li><a href="#version-control-systems">Version Control Systems</a>
<ul>
<li><a href="#what-is-version-control">What is version control?</a></li>
<li><a href="#version-control-and-automation">Version Control and Automation</a></li>
<li><a href="#what-is-git">What is Git?</a></li>
<li><a href="#more-information-about-git">More Information About Git</a></li>
<li><a href="#installing-git">Installing Git</a></li>
</ul>
</li>
<li><a href="#using-git">Using Git</a>
<ul>
<li><a href="#first-steps-with-git">First Steps with Git</a></li>
<li><a href="#tracking-files">Tracking Files</a></li>
<li><a href="#the-basic-git-workflow">The Basic Git Workflow</a></li>
<li><a href="#anatomy-of-a-commit-message">Anatomy of a Commit Message</a></li>
<li><a href="#initial-git-cheat-sheet">Initial Git Cheat Sheet</a></li>
</ul>
</li>
<li><a href="#using-git-locally">Using Git Locally</a>
<ul>
<li><a href="#advanced-git-operations">Advanced Git Operations</a></li>
<li><a href="#getting-more-information-about-our-changes">Getting More Information About Our Changes</a></li>
<li><a href="#deleting-and-renaming-files">Deleting and Renaming Files</a></li>
</ul>
</li>
<li><a href="#undoing-things">Undoing Things</a>
<ul>
<li><a href="#undoing-changes-before-committing">Undoing Changes Before Committing</a></li>
<li><a href="#amending-commits">Amending Commits</a></li>
<li><a href="#rollback">Rollback</a></li>
<li><a href="#identifying-a-commit">Identifying a Commit</a></li>
</ul>
</li>
<li><a href="#branching-and-merging">Branching and Merging</a>
<ul>
<li><a href="#what-is-a-branch">What is a branch?</a></li>
<li><a href="#creating-new-branches">Creating new branches</a></li>
<li><a href="#working-with-branches">Working with Branches</a></li>
<li><a href="#merging">Merging</a></li>
<li><a href="#merge-conflicts">Merge conflicts</a></li>
</ul>
</li>
<li><a href="#working-with-remotes">Working with Remotes</a>
<ul>
<li><a href="#what-is-github">What is GitHub?</a></li>
<li><a href="#basic-interaction-with-github">Basic Interaction with GitHub</a></li>
<li><a href="#what-is-a-remote">What is a remote?</a></li>
<li><a href="#working-with-remotes-1">Working with remotes</a></li>
<li><a href="#fetching-new-changes">Fetching New Changes</a></li>
<li><a href="#updating-the-local-repository">Updating the Local Repository</a></li>
</ul>
</li>
<li><a href="#solving-conflicts">Solving Conflicts</a>
<ul>
<li><a href="#the-pull-merge-push-workflow">The Pull-Merge-Push Workflow</a></li>
<li><a href="#pushing-remote-branches">Pushing Remote Branches</a></li>
<li><a href="#rebasing-your-changes">Rebasing Your Changes</a></li>
<li><a href="#another-rebasing-example">Another Rebasing Example</a></li>
<li><a href="#best-practices-for-collaboration">Best Practices for Collaboration</a></li>
<li><a href="#module-3-review">Module 3 Review</a></li>
</ul>
</li>
<li><a href="#collaboration">Collaboration</a>
<ul>
<li><a href="#intro-to-collaboration">Intro to Collaboration</a></li>
<li><a href="#a-simple-pull-request-on-github">A Simple Pull Request on GitHub</a></li>
<li><a href="#the-typical-pull-request-workflow-on-github">The Typical Pull Request Workflow on GitHub</a></li>
<li><a href="#updating-an-existing-pull-request">Updating an Existing Pull Request</a></li>
<li><a href="#squashing-changes">Squashing Changes</a></li>
<li><a href="#git-fork-and-pull-request-cheat-sheet">Git Fork and Pull Request Cheat-Sheet</a></li>
</ul>
</li>
<li><a href="#code-reviews">Code Reviews</a>
<ul>
<li><a href="#what-are-code-reviews">What are code reviews?</a></li>
<li><a href="#the-code-review-workflow">The Code Review Workflow</a></li>
<li><a href="#how-to-use-code-reviews-in-github">How to Use Code Reviews in GitHub</a></li>
<li><a href="#more-information-on-code-reviews">More Information on Code Reviews</a></li>
</ul>
</li>
<li><a href="#managing-projects">Managing Projects</a>
<ul>
<li><a href="#managing-collaboration">Managing Collaboration</a></li>
<li><a href="#tracking-issues">Tracking Issues</a></li>
<li><a href="#continuous-integration">Continuous Integration</a></li>
<li><a href="#additional-tools">Additional Tools</a></li>
<li><a href="#module-4-collaboration---wrap-up">Module 4: Collaboration - Wrap Up</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="introduction-to-git-and-github">3. Introduction to Git and GitHub</h1>
<h2 id="before-version-control">Before Version Control</h2>
<h3 id="module-introduction">Module Introduction</h3>
<p>When you work in IT, you manage information across a lot of different files:</p>
<ul>
<li>
<p>You write automation scripts that might evolve over time. For example, you might add new features to your script or take into account additional conditions or modify the scope of systems where the script will be executed.</p>
</li>
<li>
<p>You also manage configuration related to your infrastructure like the default settings on an application or the IP addresses assigned to the computers in your fleet, etc.</p>
</li>
</ul>
<p>This information changes over time as the security requirements increase. The fleet grows or new versions of software gets deployed.</p>
<p>When trying to manage change in IT, it’s super important to have detailed historical information for your organization’s configuration files and automation code. This let’s the administrators see what was modified and when, which can be critical to troubleshooting. It also provides a documentation trail that will let future IT specialists know why the infrastructure is the way it is, and it provides a mechanism for undoing a change completely. This way, we don’t have to undo changes from memory and there’s less chance of human error. We’ll see this in action when we talk about rollbacks.</p>
<p>Imagine this, your team has added a new feature to a script that checks the health of all the computers that you’re responsible for. The new check verifies that the firmware of the computer, also known as the UEFI, is updated to the latest version. When you roll this out, you suddenly realize that half the computers now say they’re broken. After some investigation, you discover that the check needs to take into account different computer models.</p>
<p>You might be tempted to do a quick code fix, push it to the affected machines right away especially if it seems like an easy fix. But more often than not, quick fixes include their own bugs because we don’t take the time to test a new code properly. So after the first fix, you might end up doing a second or even third emergency push until things are really working correctly. To avoid these headaches, you can use a version control system to easily roll back your code to the previous version. Since you know that this version was working correctly before the change was made, it would be safe to go back to that one until you had time to fix the code, run some tests, and make sure everything works correctly for all machine models.</p>
<p>By releasing code only after properly testing, you avoid having to push quick-fix after quick-fix. Version control systems let us do this and much more. They are crucial to maintaining a healthy codebase for all kinds of IT resources, and for letting multiple people collaborate on the same coding projects together.</p>
<p>We’re now going to take our first steps to learning this new tool, which will let us keep track of the changes that we make to our scripts, our configuration files, and any other kind of documents that need to be tracked.</p>
<p>We’ll start by looking at what people tend to do when they don’t know about version control and then check out some related tools, like <strong>diff</strong> and <strong>patch</strong>.</p>
<p>Once we have a clear idea of why we need proper version control, we’ll jump into our first <strong>Git</strong> experience. We’ll talk about what <strong>Git</strong> is and how it does what it does.</p>
<p>To follow along, you’ll need to install Git locally on your machine and learn how to use it from the command line. If this sounds a bit scary, don’t panic. We’ll guide you along the way and you’ll be using it in no time. Once you have Git installed in your computer, we’ll do an overview of the basic Git workflow which will let you start keeping track of your scripts.</p>
<h3 id="keeping-historical-copies">Keeping Historical Copies</h3>
<p>The principle behind version control is the following one: it lets us keep track of the changes in our files. These files can be <em>code</em>, <em>images</em>, <em>configuration</em>, or even a <em>video editing project</em>, <em>whatever</em> it is you’re working with. Throughout this course, we’ll see the many ways that <strong>Git</strong> helps us keep track of our changes, and also how we can use it to collaborate with others or avert changes. We’ll use a bunch of terms that have special meanings in the world of version control, but don’t let those intimidate you. In the end, all we’re doing is having better control over our historical copies. So, say you have two copies of the same code made at different points in time. How can you compare them?</p>
<h3 id="diffing-files">Diffing Files</h3>
<p>Imagine you had two copies of some code, and you wanted to see what the difference was between them. How would you do it? You could open both files in the editor side by side, look at one then look at the other to spot the differences, but that’s super error-prone. We’re human and by comparing with our eyes we are bound to miss some differences. Fortunately, there’s a better way. You can use some nifty tools that will do this automatically. We can use the diff command line tool to take two files or even to directories, and show the differences between them in a few formats.</p>
<p>Let’s say we have two files rearrange <a href="http://1.py">1.py</a> and rearrange <a href="http://2.py">2.py</a> which contain two different versions of the same function. We could take a look at them using <strong>cat</strong>. Could you spot the difference? Maybe you can but it’s not super obvious. Let’s use the <strong>diff</strong> command so that we don’t have to<br>
strain our eyes trying to spot it.</p>
<p>When we call the diff command, we get only the lines that are different between two files. It’s much easier to find the difference when we just have two lines.</p>
<p>When differences or changes are less so obvious or common, we can use the <strong>diff -u</strong> flag to tell diff to show the differences in another format. This <em>unified format</em> is pretty different from the one that we saw before. It shows the change lines together with some context, using the minus sign to mark lines that were removed, and the plus sign to mark lines that were added. The extra context let’s us better know what’s going on with the change that we’re diffing.</p>
<h3 id="applying-changes">Applying Changes</h3>
<p>Imagine a colleague sends you a script with a bug and asked you to help fix the issue. Once you understood what was wrong with the script, you could describe to them what they need to change. Something like, <em>“Well, you can only return values inside functions. I think you meant to use sys.exit instead. Also, you’re converting to gigabytes twice, so your script will always fail.”</em></p>
<p>But this could still be hard for them to understand if the code is complex. To make the change clear, you could send them a diff with the change so that they can see what the modified code looks like. To do this, we typically use a command line like:</p>
<pre class=" language-bash"><code class="prism  language-bash">diff-u old_file new_file <span class="token operator">&gt;</span> change.diff.
</code></pre>
<p>As a reminder, the greater than sign redirects the output of the diff command to a file. So with this command, we’re generating a file called change.diff with the contents of diff-u command. By using the -u flag, we include more context which helps the person reading the file understand what’s going on with the change. The generated file is usually referred to as a <strong>diff file</strong> or sometimes a <strong>patch file</strong>. It includes all the changes between the old file and the new one, plus the additional context needed to understand the changes and to apply those changes back to the original file.</p>
<p>Now, say you’re the one receiving a diff file with a change and you want to apply it to a script you wrote. You could read the diff file you receive carefully and then manually go through the file that needs to be changed, and apply the modifications. But it sounds like a lot of manual work that could be automated, don’t you think? Well, it sure is.</p>
<p>There’s a command called patch to do exactly this. Patch takes a file generated by diff and applies the changes to the original file. Let’s check this out in an example. Say we have a small script that checks whether the computer is under too much load, like this one.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment">#!/usr/bin/env python3</span>

<span class="token keyword">import</span> psutil

<span class="token keyword">def</span> <span class="token function">check_cpu_usage</span><span class="token punctuation">(</span>percent<span class="token punctuation">)</span><span class="token punctuation">:</span>
  usage <span class="token operator">=</span> psutil<span class="token punctuation">.</span>cpu_percent<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> usage <span class="token operator">&lt;</span> percent

<span class="token keyword">if</span> <span class="token operator">not</span> check_cpu_usage<span class="token punctuation">(</span><span class="token number">75</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ERROR! CPU is overloaded"</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Everything ok"</span><span class="token punctuation">)</span>
</code></pre>
<p>This script uses the psutil module to check the percentage of the CPU that’s currently in use. When the load is above a threshold, in this case 75 percent, it prints a message with an error. When it’s under the threshold, it says that everything’s okay.</p>
<p>Now, we’ve shared this script with a few colleagues and one of them tells us that the script doesn’t work correctly. Even if a computer is completely overloaded, the script will say that everything’s okay. Our colleague is so helpful that they sent us a diff with the fix for our problem. Let’s check that one out.</p>
<pre class=" language-bash"><code class="prism  language-bash">--- cpu_usage.py        2023-01-17 18:19:26.000000000 +0100
+++ cpu_usage2.py       2023-01-17 18:21:20.000000000 +0100
@@ -3,7 +3,8 @@
 <span class="token function">import</span> psutil

 def check_cpu_usage<span class="token punctuation">(</span>percent<span class="token punctuation">)</span>:
-  usage <span class="token operator">=</span> psutil.cpu_percent<span class="token punctuation">(</span><span class="token punctuation">)</span>
+  usage <span class="token operator">=</span> psutil.cpu_percent<span class="token punctuation">(</span>1<span class="token punctuation">)</span>
+  print<span class="token punctuation">(</span><span class="token string">"DEBUG: usage: {}"</span>.format<span class="token punctuation">(</span>usage<span class="token punctuation">))</span>
   <span class="token keyword">return</span> usage <span class="token operator">&lt;</span> percent

 <span class="token keyword">if</span> not check_cpu_usage<span class="token punctuation">(</span>75<span class="token punctuation">)</span>:
</code></pre>
<p>We can see that our colleague made two changes. They added a one as a parameter to the CPU percent function and they added a debugging line, that prints the value returned by the function. Our colleague explains that by calling the CPU percent function without a parameter, we were not averaging over a period of time, and so the call always returns zero.</p>
<p>So we have the diff file and we want to apply it to our script. How do we do that? We’ll use the <strong>patch</strong> command. We’ll pass the name of the file that we want to patch in this case, cpu_usage.py, as the first parameter to the command and then we’ll provide the diff file through standard input. Let’s check this out:</p>
<pre class=" language-bash"><code class="prism  language-bash">$ patch cpu_usage.py <span class="token operator">&lt;</span> cpu_usage.diff
patching <span class="token function">file</span> cpu_usage.py
</code></pre>
<p>So we told patch to apply the changes that come from cpu_usage.diff to our cpu_usage.py file. We get one single line that says the file was patched, which means that we’ve successfully applied the changes. Let’s verify that by looking at the contents of our script. Nice. We see that our file was modified with the changes that we got from our colleague. The CPU percent function is being called with a parameter of one and the debugging line is printed. Once we’re happy with the script, we could remove the debugging line. But for now, we’ll leave it in there.</p>
<p>You might be wondering, why go through all this trouble diffing, and patching, and not just send the whole file instead? There are a few reasons for this?</p>
<ul>
<li>
<p>The main reason is that the original code could have changed. In our example, it’s possible that the code our colleague was using to prepare the fix wasn’t the latest version. By using a diff instead of the whole file, we can clearly see what they changed, no matter which version they were using. The <strong>patch</strong> command can detect that there were changes made to the file and will do its best to apply the diff anyways. It won’t always succeed but in many cases it will.</p>
</li>
<li>
<p>Another reason is structure. In this case we’re patching a single small file. But sometimes, you might be modifying a bunch of large files inside of a huge project. Say you are changing four files in a project tree that contain 100 different files, arranged in different directories according to what they do. If you were to send the whole files, you’d need to specify where those files were supposed to be placed. As we called out,<em>** we can diff whole directory structures and in that case the diff file can specify where each change file should be without us having to do any manual juggling**</em>. Cool right? Great work. We’ve now seen how to generate diff files and how to apply their contents with the patch command.</p>
</li>
</ul>
<h3 id="practical-application-of-diff-and-patch">Practical Application of diff and patch</h3>
<p>Imagine this, a colleague is asking our help with fixing a script named disk_usage.py.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment">#!/usr/bin/env python3</span>

<span class="token keyword">import</span> shutil

<span class="token keyword">def</span> <span class="token function">check_disk_usage</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> min_absolute<span class="token punctuation">,</span> min_percent<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"Returns True if there is enough free disk space, False otherwise"</span>
    du <span class="token operator">=</span> shutil<span class="token punctuation">.</span>disk_usage<span class="token punctuation">(</span>disk<span class="token punctuation">)</span>
    <span class="token comment"># Calculate the percentage of free space</span>
    percent_free <span class="token operator">=</span> du<span class="token punctuation">.</span>free <span class="token operator">/</span> du<span class="token punctuation">.</span>total <span class="token operator">*</span> <span class="token number">100</span>
    <span class="token comment"># Calculate how many free gigabytes are left</span>
    gigabytes_free <span class="token operator">=</span> du<span class="token punctuation">.</span>free <span class="token operator">/</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">30</span>
    <span class="token keyword">if</span> gigabytes_free <span class="token operator">&lt;</span> min_percent <span class="token operator">or</span> gigabytes_free <span class="token operator">&lt;</span> min_absolute<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>


<span class="token comment"># Check for at least 2 GB and 10% free space</span>
<span class="token keyword">if</span> <span class="token operator">not</span> check_disk_usage<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ERROR: Not enough disk space"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Everything ok"</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> <span class="token number">0</span>
</code></pre>
<p>The goal of the script is to check how much disk space is currently used, and print an error if it’s too little space for normal operation. But the script is currently broken because it has a few bugs. We’ll help our colleague fix those bugs to demonstrate how to use diff and patch. Before we change anything, let’s make a couple copies of the script. We’ll add _original to one copy, which we’ll keep unmodified and use for comparison and _fixed to the other copy, which we’ll use to repair our fix.</p>
<pre class=" language-bash"><code class="prism  language-bash">$ <span class="token function">cp</span> disk_usage.py disk_usage_orginal.py
<span class="token punctuation">..</span>.
$ <span class="token function">cp</span> disk_usage.py disk_usage_fixed.py
</code></pre>
<p>Now that we have our copies, we’ll edit the _fixed version and actually fix it. This file has a bunch of code. Before we try to understand what it does and what’s wrong with it, let’s execute it and see what we get.</p>
<pre class=" language-bash"><code class="prism  language-bash">$ ./disk_usage.py
File <span class="token string">"disk_usage.py"</span>, line 20
    <span class="token keyword">return</span> 1
    ^^^^^^^^
SyntaxError: <span class="token string">'return'</span> outside <span class="token keyword">function</span>
</code></pre>
<p>The Python interpreter isn’t too happy. It’s complaining that there’s a return outside of function. And if we look at the code, we can clearly see that there’s a return that’s not inside any function.</p>
<p>You might remember that in Python, we can only use return statements inside functions. So how do we fix this? There’s a couple options. We could turn the current code into a function and then call that function from the main part of our script. Or we could use sys.exit to make the return number of the exit code of our script, which is the code that causes a program to exit with the corresponding exit value. For now, let’s go with the second option.</p>
<p>We’ve made the change. Let’s execute this new version of our script.</p>
<pre class=" language-bash"><code class="prism  language-bash">$ ./disk_usage.py
ERROR: Not enough disk space
</code></pre>
<p>Darn, we fixed the syntax error, but now the script is telling us we don’t have enough space on our disk. But we know that we actually do have some free space, right? What’s up with that?</p>
<p>If you look closely at the code, you might notice that the script is converting to gigabytes twice. The function call to check_disk_usage is passing 2 times 2 double star 30. You might remember that the double star operator is used to calculate powers. In this case, 2 to the power of 30, which is how many bytes are in a gigabyte. So, this would be 2 gigabytes, but that be if the check_disk_usage function was expecting a value in bytes. If we look at the code of the function, we can see that it’s already dividing the amount of free bytes by 2 to the power of 30. So in other words, we’re doing the gigabyte conversion twice. Once when calling the function and once inside the function. We need to get rid of one of them. Let’s change how we call the function.</p>
<p>Let’s try it out again.</p>
<pre class=" language-bash"><code class="prism  language-bash">$ ./disk_usage.py
Everything ok
</code></pre>
<p>It works now. Okay, now we need to send a fixed to our colleague so that they can fix their script. To do that, we’ll use a technique we just learned to generate a diff file, like this:</p>
<pre class=" language-bash"><code class="prism  language-bash">$ <span class="token function">diff</span> -u check_usage_orginal.py check_usage_fixed <span class="token operator">&gt;</span> check_usage.diff
<span class="token punctuation">..</span>.
$ <span class="token function">cat</span> check_usage.diff <span class="token comment"># just to check</span>
--- disk_usage_original.py      2023-01-18 12:08:03.000000000 +0100
+++ disk_usage_fixed.py 2023-01-18 15:06:46.000000000 +0100
@@ -15,8 +15,11 @@


 <span class="token comment"># Check for at least 2 GB and 10% free space</span>
-if not check_disk_usage<span class="token punctuation">(</span><span class="token string">"/"</span>, 2*2**30, 10<span class="token punctuation">)</span>:
+if not check_disk_usage<span class="token punctuation">(</span><span class="token string">"/"</span>, 2, 10<span class="token punctuation">)</span>:
     print<span class="token punctuation">(</span><span class="token string">"ERROR: Not enough disk space"</span><span class="token punctuation">)</span>
-    <span class="token keyword">return</span> 1
+    sys.exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span>
 print<span class="token punctuation">(</span><span class="token string">"Everything ok"</span><span class="token punctuation">)</span>
-return 0
+sys.exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span>
</code></pre>
<p>Awesome. This seems to have what we want. So this is what we need to send to our colleague to have them patch their file. How would they do that? They would run the patch command like this.</p>
<pre class=" language-bash"><code class="prism  language-bash">$ patch disk_usage.py <span class="token operator">&lt;</span> disk_usage.diff
patching <span class="token function">file</span> disk_usage.py
</code></pre>
<p>By calling patch with the diff file, we’ve applied the changes that were necessary to fix the bugs.</p>
<p>So we’ve now seen how we can look at differences between files, generate diff files together to gather our changes, and then apply those changes using patch. But this is still a very manual process, where version control systems can really help.</p>
<h2 id="version-control-systems">Version Control Systems</h2>
<h3 id="what-is-version-control">What is version control?</h3>
<p>We’ve seen up till now, how we can use existing tools to extract differences between versions of files and apply those changes back to the original files. Those tools are really useful. But most of the time, we won’t be using them directly. Instead, we’ll use them through a Version Control System, or VCS.</p>
<p><em>A Version Control System keeps track of the changes that we make to our files</em>. By using a VCS, we can know when the changes were made and who made them. It also lets us easily revert a change if it turned out not to be a good idea. It makes collaboration easier by allowing us to merge changes from lots of different sources.</p>
<p>At first-look, a Version Control System can seem like a complicated, possibly intimidating tool. But if you look closer, you’ll see that it’s really just a system that stores files. However, unlike a regular file server which only saves the most recent version of a file, a VCS keeps track of all the different versions that we create as we save our changes. There are many different version control systems, each with their own implementation and with their own advantages and disadvantages. But, no matter how the VCS is implemented internally, they always access the history of our files. Let us retrieve past versions of the file or directory and see who changed which files, how each file was changed and when the file was changed. On top of this, we can make edits to multiple files and treat that collection of edits as a single change which is commonly known as a, <strong>commit</strong>.</p>
<p>A VCS even provides a mechanism to allow the author of a commit to record why the change was made, including what bugs, tickets or issues were fixed by the change. <em>This information can be a lifesaver when trying to understand a complex series of changes, or to debug some obscure issue. So, be sure to record this extra info in your commits to be truly committed to better code.</em></p>
<p>In any organization that produces software, a VCS is a key part of managing the code. Files are usually organized in <strong>repositories</strong> which contains separate software projects or just group all related code. If there’s a lot of people involved in developing software, some developers may have access to only some of the repositories. A single <strong>repository</strong> can have as little as one person using it. And it can go up to thousands of contributors.</p>
<p>And, as we called that earlier, a Version Control System can be used to store much more than just code. We can use it to store configuration files, documentation, data files, or any other content that we may need to track. Because of the way tools like diff and patch work, a VCS is especially useful when tracking text files, which can be compared with diff and modified with patch. We can also store images, videos or any other complex file formats in a VCS, but, it won’t be easy to check the differences between versions when comparing these file formats.</p>
<h3 id="version-control-and-automation">Version Control and Automation</h3>
<p>At first glance, using a VCS might seem like a lot of work for an IT specialist to set up and learn. It might especially seem like overkill, if you’re the only member of your IT team that writes code or maybe even the only member period. So can a VCS help, even if you don’t need to share your scripts or collaborate on them with others?</p>
<p>The short answer is yes. A VCS can be invaluable, even in a one-person IT department. A VCS stores your code and configuration. It also stores the history of that code and configuration. A version control system can function a lot like a time machine, giving you insights into the decisions of the past. Whenever you write a commit message, after making a change, it’s as if the current version of yourself is explaining your decisions to a future you or others who might work on the same scripts and configurations in the future. This can help you avoid finding yourself staring at a piece of code that you or someone else wrote three months ago and puzzling over how it works or even why it exists. With a VCS, you can view, track and select snapshots from the history of your project. So nothing you do is lost, and since we can use a VCS to store both code and configuration files, we can make the overall IT systems more scalable and reliable.</p>
<p>This functionality enhances the reliability of systems you operate. Because of the audit trail provided by the VCS, you know exactly what version of the zone file to rollback to, which reduces the time it takes to fix the problem. It’s generally better to quickly roll back first and stop errors before spending time figuring out what went wrong. You can curb the fix after the bleeding has stopped. Figuring out the bug might take up valuable time or worse, your first attempt at a solution can have its own bugs.</p>
<h3 id="what-is-git">What is Git?</h3>
<p>Git is a VCS created in 2005 by Linus Torvalds. The developer who started the Linux kernel.</p>
<p>Git is a free open source system available for installation on Unix based platforms, Windows and macOS. Linus originally created get to help manage the task of developing the Linux kernel. This was difficult because a lot of geographically distributed programmers were collaborating to write a whole bunch of code. Linus had some requirements for the way that the system worked, and its performance that weren’t being met by the VCS tools at a time. So he decided to write his own. Git is now one of the most popular version control systems out there and is used in millions of projects. Unlike some version control systems that are centralized around a single server, Git has a distributed architecture. This means that every person contributing to a repository has full copy of the repository on their own development machines.</p>
<p>Collaborators can share and pull in changes that others have made as they need. And because the repositories are all local to the computer being used to create the files, most operations can be done really fast. If you want to collaborate with others, it usually makes sense to set up a repository on a server to act as a kind of hub for everyone to interact with. But Git doesn’t rely on any kind of centralized server to provide control organizations to its workflow. Git can work as a standalone program as a server and as a client. This means that you can use Git on a single machine without even having a network connection. Or you can use it as a server on a machine where you want to host your repository. And then you can use Git as a client to access the repository from another machine or even the same one. Git clients can communicate with Git servers over the network using HTTP, SSH or Git’s own special protocol.</p>
<p>So you can use Git with or without a network connection. You can use it for small projects with like one developer or huge projects with thousands of contributors. You can use it to track private work that you can keep to yourself or you can share your work with others by hosting a code on public servers like Github, Gitlab or others.</p>
<p>As with most things in the IT world, though, there are plenty of other tools that can be used to accomplish the same task. There are other VCS programs like Subversion or Mercurial. Feel free to experiment with alternatives if you think another VCS might better serve your needs.</p>
<h3 id="more-information-about-git">More Information About Git</h3>
<p>Check out the following links for more information:</p>
<ul>
<li>
<p><a href="https://git-scm.com/doc">https://git-scm.com/doc</a></p>
</li>
<li>
<p><a href="https://www.mercurial-scm.org/">https://www.mercurial-scm.org/</a></p>
</li>
<li>
<p><a href="https://subversion.apache.org/">https://subversion.apache.org/</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Version_control">https://en.wikipedia.org/wiki/Version_control</a></p>
</li>
</ul>
<h3 id="installing-git">Installing Git</h3>
<p>The first step on the way to using Git is to install it! The directions found in the Git documentation below are pretty thorough and helpful, check them out for the best method of getting Git onto your platform of choice.</p>
<ul>
<li>
<p><a href="https://git-scm.com/downloads">Git download page</a></p>
</li>
<li>
<p><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Git installation instructions for each platform</a></p>
</li>
</ul>
<h2 id="using-git">Using Git</h2>
<h3 id="first-steps-with-git">First Steps with Git</h3>
<p>When starting with Git, there are a bunch of concepts that we need to learn to understand how things are organized and how our files are tracked.</p>
<p>Let’s start by setting some basic configuration. Remember when we said that a VCS tracks who made which changes, for this to work, we need to tell Git who we are. We can do this by using the <strong>git config</strong> command and then setting the values of user.email and <a href="http://user.name">user.name</a> to our email and our name like this:</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">git</span> config --global user.email <span class="token string">"me@example.com"</span>
<span class="token function">git</span> config --global user.name <span class="token string">"My Name"</span>
</code></pre>
<p>With that done, there are two ways to start working with a git repository. We can create one from scratch using the <strong>git ini</strong>t command or we can use the <strong>git clone</strong> command to make a copy of a repository that already exists somewhere else. We’ll talk about remote repositories later in the course. For now, let’s start by creating a new directory and then a git repository inside that directory.</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> checks
<span class="token function">cd</span> checks
<span class="token function">git</span> init
Initialized empty Git repository <span class="token keyword">in</span> ~/checks/.git/
</code></pre>
<p>So when we run <strong>git init</strong> we initialize an empty git repository in the current directory. The message that we get mentions a directory called. git. We can check that this directory exist using the <strong>ls -la</strong> command which lists files that start with a dot. We can also use the <strong>ls -l .git</strong> command to look inside of it and see the many different things it contains. This is called a <em>Git directory</em>.</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">ls</span> -l .git
Total 24
-rw-r--r--   1 user  staff   23 20 jan 17:16 HEAD
-rw-r--r--   1 user  staff  137 20 jan 17:16 config
-rw-r--r--   1 user  staff   73 20 jan 17:16 description
drwxr-xr-x  15 user  staff  480 20 jan 17:16 hooks
drwxr-xr-x   3 user  staff   96 20 jan 17:16 info
drwxr-xr-x   4 user  staff  128 20 jan 17:16 objects
drwxr-xr-x   4 user  staff  128 20 jan 17:16 refs
</code></pre>
<blockquote>
<p><em>If you’ve already run git init on a project directory containing a .git subdirectory, you can safely run git init again on the same project directory. The operation is what we call <strong>idempotent</strong>; running it again doesn’t override an existing .git configuration.</em></p>
</blockquote>
<p>You can think of it as a database for your Git project that stores the changes and the change history. We can see it contains a bunch of different files and directories. We won’t touch any of these files directly, we’ll always interact with them through Git commands. So whenever you clone a repository, this git directory is copied to your computer. Whenever you run git init to create a new repository like we just did, a new git directory is initialized.</p>
<p>The area outside the git directory is the <em><strong>working tree</strong></em>. The <em><strong>working tree</strong></em> is the current version of your project. You can think of it like a workbench or a sandbox where you perform all the modification you want to your file. This working tree will contain all the files that are currently tracked by Git and any new files that we haven’t yet added to the list of track files.</p>
<p>Right now our working tree is empty. Let’s change that by copying the disk usage that pyfile that we created earlier into our current directory.</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">cp</span> <span class="token punctuation">..</span>/disk_usage.py <span class="token keyword">.</span>
</code></pre>
<p>We now have file and a working tree but it’s currently untracked by Git. To make Git track our file, we’ll add it to the project using the <strong>git add</strong> command passing the file that we want as a parameter. With that, we’ve added our file to the <em><strong>staging area</strong></em>.</p>
<p>The staging area which is also known as the <em><strong>index</strong></em> is a file maintained by Git that contains all of the information about what files and changes are going to go into your next command.</p>
<p>We can use the <strong>git status</strong> command to get some information about the current working tree and pending changes.</p>
<p>To get our file committed into the.git directory, we run the <strong>git commit</strong> command.</p>
<p>When we run this command, we tell Git that we want to save our changes. It opens a text editor where we can enter a commit message. The texts that we get tells us that we need to write a commit message and that the change to be committed is the new file that we’ve added. For now, let’s enter a simple description of what we did which was to add this one file and then exit the editor saving our commit message and with that we’ve created our first git commit.</p>
<h3 id="tracking-files">Tracking Files</h3>
<p>In the previous section, we mentioned that any Git project will consist of three sections: the Git directory, the working tree and the staging area.</p>
<ul>
<li>
<p>The <em><strong>Git directory</strong></em> contains the history of all the files and changes.</p>
</li>
<li>
<p>The <em><strong>working tree</strong></em> contains the current state of the project, including any changes that we’ve made.</p>
</li>
<li>
<p>And <em><strong>the staging area</strong></em> contains the changes that have been marked to be included in the next commit.</p>
</li>
</ul>
<p>This can still be confusing. So it might be helpful to think about Git as representing your project. Which is the code and associated files and a series of snapshots.</p>
<p>Each time you make a commit, Git records a new snapshot of the state of your project at that moment. It’s a picture of exactly how all these files looked at a certain moment in time. Combined, these snapshots make up the history of your project, and it’s information that gets stored in the Git directory. Now, let’s dive into the details of how we track changes to our files.</p>
<p>When we operate with Git, our files can be either <em><strong>tracked</strong></em> or <em><strong>untracked</strong></em>. Tracked files are part of the snapshots, while untracked files aren’t a part of snapshots yet. This is the usual case for new files.</p>
<p>Each tracked  file can be in one of three main states: <em><strong>modified</strong></em>, <em><strong>staged</strong></em> or <em><strong>committed</strong></em>. Let’s look at what each of these mean.</p>
<ul>
<li>
<p>If a file is in the modified state, it means that we’ve made changes to it that we haven’t committed yet. The changes could be adding, modifying or deleting the contents of the file. Git notices anytime we modify our files. But won’t store any changes until we add them to the staging area.</p>
</li>
<li>
<p>So, the next step is to stage those changes. When we do this, our modified files become staged files. In other words, the changes to those files are ready to be committed to the project. All files that are staged will be part of the next snapshot we take.</p>
</li>
<li>
<p>And finally, when a file gets committed, the changes made to it are safely stored in a snapshot in the Git directory.<br>
This means that typically a file tracked by Git, will first be modified when we change it in any way. Then it becomes staged when we mark those changes for tracking. And finally it will get committed when we store those changes in the VCS.</p>
</li>
</ul>
<p>So to sum up, we work on modified files in our working tree. When they’re ready, we staged these files by adding them to the staging area. Finally, we commit the changes sitting in our staging area, which takes a snapshot of those files and stores them in the database that lives in the Git directory. If the way Git works is not totally clear yet, don’t worry. It will all sink in with a bit more practice.</p>
<h3 id="the-basic-git-workflow">The Basic Git Workflow</h3>
<p>We discussed earlier some of the basic concepts involved in working with <strong>Git</strong>. We saw that each repository will have a <em><strong>Git directory</strong></em>, a_** working tree**_, and a <em><strong>staging area</strong></em>. And we called out that files can be in three different states, modified, staged, and committed. Let’s review these concepts one more time by looking at the normal workflow when operating with Git on a day to day basis.</p>
<ul>
<li>First, all the files we want to manage with Git must be a part of a Git repository. We initialize a new repository by running the git init command in any file system directory. For example, let’s use the mkdir command to create a directory called scripts, and then change into it and initialize an empty Git repository init.</li>
</ul>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">mkdir</span> scripts
<span class="token function">cd</span> scripts
<span class="token function">git</span> init
</code></pre>
<p>Our shiny new Git repository can now be used to track changes to files inside of it. But before jumping into that, let’s check out our current configuration by using the <strong>git config -l</strong> command. There’s a bunch of info in there, and we won’t cover all of it. For now, pay special attention to the <em>user.email</em> and the <em><a href="http://user.name">user.name</a></em> lines, which we touched on briefly in an earlier video. This information will appear in public commit logs if you use a shared repository. For privacy reasons, you might want to use different identities when dealing with your private work and when submitting code to public repositories. We’ll include more details about changing this information in our next reading.</p>
<p>Our repo is ready to work, but it’s currently empty. Let’s create a file in it, we’ll start with a basic skeleton for a Python script, which will help us demonstrate the Git workflow. As with any Python script, we’ll start with the shebang line. For now, we’ll add an empty main function, which we’ll fill in later. And at the end, we’ll just call this main function.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment">#!/usr/bin/env python3</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">pass</span>

main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>All right, we’ve created our file. This is a script that we’ll want to execute, so let’s make it executable. And then let’s check the status of our repo using <strong>git status</strong> command.</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">git</span> status
</code></pre>
<ul>
<li>
<p>As we called out before, when we create a new file in a repository, it starts off as untracked. We can make all kinds of changes to the file, but until we tell Git to track it, Git won’t do anything with an untracked file. We need to call the <strong>git add</strong> command. This command will immediately move a new file from untracked to stage status. And as we’ll see later, it will also change a file in the modified state to staged state. Remember that when a file is staged, it means it’s been added to the staging area and it’s ready to be committed to the Git repository.</p>
</li>
<li>
<p>To initiate a commit of staged files, we issue the <strong>git commit</strong> command. When we do this, Git will only commit the changes that have been added to the staging area, untracked files or modified files that weren’t staged will be ignored. Calling git commit with no parameters will launch a text editor, this will open whatever has been set as your default editor. If the default editor is not the one you’d like to use, there are a bunch of ways to change it. For now, let’s edit our message with Nano, which is the current default for this computer. We’ll say that our change is creating an empty all_checks.py file, then save and exit.</p>
</li>
</ul>
<p>Voila! We’ve just recorded a snapshot of the code in our project, which is stored in the Git directory. Remember that every time we commit changes, we take another snapshot, which is annotated with a commit message that we can review later.</p>
<ul>
<li>Okay, that’s how we add new files, but usually we’ll modify existing ones. So let’s add a bit more content to our script to see that in action. We’ll add a function called check_reboot, that will check if the computer is pending a reboot. To do that, we’ll check if the run/reboot-required file exists. This is a file that’s created on our computer when some software requires a reboot. And of course, since we’re using os.path.exists, we need to add import os to our script.</li>
</ul>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment">#!/usr/bin/env python3</span>
<span class="token keyword">import</span> os

<span class="token keyword">def</span> <span class="token function">check_reboot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token string">"Returns True if the computer has a pendign reboot"</span>
  <span class="token keyword">return</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">"/run/reboot-required"</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">pass</span>

main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<ul>
<li>
<p>All right, we’ve added a function to our file. Let’s check the current status using <strong>git status</strong> again. Our file’s <em>modified</em>, but not <em>staged</em>. To stage our changes, we need to call <strong>git add</strong> once again.</p>
</li>
<li>
<p>Okay, our changes our now staged. We have to call <strong>git commit</strong> to store those changes to the Git directory. This time, we’ll use the other way of setting the commit message. We’ll call <strong>git commit -m</strong>, and then pass the commit message that we want to use. So in this case, we’ll say that we’ve added the check_reboot function.</p>
</li>
</ul>
<p>With that, we’ve demonstrated the basic Git workflow. We make changes to our files, stage them with git add, and commit them with git commit. If there’s anything that’s not totally clear yet, remember, that the only way to get familiar with these concepts is practice.</p>
<h3 id="anatomy-of-a-commit-message">Anatomy of a Commit Message</h3>
<p>Earlier, we saw how we can commit snapshots of changes to the Git repository. Let’s now talk a little bit more about what makes a good commit message.</p>
<p>Writing a clear informative commit message is important when you use a VCS, future you or other developers or IT specialists who might read the commit message later on will really appreciate the contextual information as they try and figure out some of the parts of the code or configuration.</p>
<p>So what makes a good commit message? It can be helpful to keep your audience in mind when you write commit messages. What would someone reading a message weeks or months from now want to know about the changes you’ve made?</p>
<ul>
<li>
<p>What might be especially important or tricky to understand about them?</p>
</li>
<li>
<p>Is there extra information that might help the reader out, like links to design documents or tickets in your ticketing system?</p>
</li>
</ul>
<p>Similarly to how style guides exist for writing code, your company might have specific rules for you to follow when you write commit messages. Even if they don’t, it’s good to use a few general guidelines to make sure your commit messages are as clear and useful as possible.</p>
<p>A commit message is generally broken up into a few sections.</p>
<ul>
<li>
<p>The first line is a short summary of the commit followed by a blank line.</p>
</li>
<li>
<p>This is followed by a full description of the changes which details why they’re necessary and anything that might be especially interesting about them or difficult to understand. When you run the git commit command, Git will open up a text editor of your choice so you can write your commit message. A good commit message might look something like this.</p>
</li>
</ul>
<p>So the first line is usually kept to about 50 characters or less. The line contains a short description of what the commit changes are about. After the first line, comes an empty line, and the rest of the text is usually kept under 72 characters. This text is intended to provide a detailed explanation of what’s going on with the change. It can reference bugs or issues that will be fixed with the change. It can also include links to more information when relevant. The line limits can be annoying but they help in making the commit message be more digestible for the reader.</p>
<p>There’s a git command used to display these commit messages called <strong>git log</strong>. This command will do any line wrapping for us. Which means that if we don’t stick to the recommended line wrapping, long commit messages will run off the edge of the screen and be difficult to read.</p>
<p>Sometimes it can be tempting to just write something short like update, change or fix as the description of our commit messages. Don’t do it. It’s super frustrating to go back to repositories history and discover that there’s not enough context to understand what was changed and why. It takes only a few more seconds to write a better description. This can be invaluable down the line.</p>
<p>Following these guidelines can help make your commit message really useful, and the investment of work now will really pay off later. If you’re interested in learning more about git commit style, there are plenty of resources out there to read including the Linux kernel documentation itself along with impassioned opinions from other developers.</p>
<h3 id="initial-git-cheat-sheet">Initial Git Cheat Sheet</h3>
<p>Check out the following links for more information:</p>
<p>The <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/submitting-patches.rst?id=HEAD">Linux kernel documentation</a> itself, as well as <a href="http://stopwritingramblingcommitmessages.com/">impassioned</a> opinions from <a href="https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message">other developers</a>.</p>
<p>You can check out <a href="https://help.github.com/articles/setting-your-email-in-git/">Setting your email in Git</a> and <a href="https://help.github.com/articles/keeping-your-email-address-private/">Keeping your email address private</a> on the GitHub help site for how to do this.</p>
<h2 id="using-git-locally">Using Git Locally</h2>
<p>Up till now, we’ve talked about what version control is, why it’s necessary, and how we might benefit from it in diverse context. We also started learning some basic Git commands, and procedures, nice job!</p>
<p>Over the course of the next sections, we’ll go into much more detail about what we can do with Git. These are Git’s greatest hits:</p>
<ul>
<li>
<p>We’ll start by learning some handy shortcuts and looking into how we can get more info out of our version control system.</p>
</li>
<li>
<p>Then we’ll experience the true power of Git by seeing how we can undo some of our changes. The ability to revert previous changes is one of the most useful aspects of version control systems. Depending on what needs to be undone, there’s a bunch of different techniques that we can use in Git. We can discard the changes made to a file, fix a commit that was incorrect and even roll back our project to an older snapshot. We’ll look into all these techniques and dive into when to use each of them.</p>
</li>
<li>
<p>Finally, we’ll check out yet another important concept, Branches. We can use branches to work on an experimental feature without affecting the main code of our project. Support separate versions of a program that can’t be merged together and much more. We’ll dive into what branches are, when and how to use them and how to deal with merge conflicts.</p>
</li>
</ul>
<h3 id="advanced-git-operations">Advanced Git Operations</h3>
<p>When we covered the basic Git workflow, we called out that the process is usually to make changes, stage them, and then commit them. The separate step between staging and committing allows us to stage several changes in one commit.</p>
<p>But if we already know that the current changes are the ones that we want to commit, we can skip the staging step and go directly to the commit. No dress rehearsals. We do this by using the <strong>-a flag</strong> to the <strong>git commit</strong> command. This flag automatically stages every file that’s tracked and modified before doing the commit letting it skip the git add step.</p>
<p>At first, you might think that git commit dash a is just a shortcut for git add followed by git commit but that’s not exactly true. Git commit -a doesn’t work on new files because those are untracked. Instead, git commit -a is a shortcut to stage any changes to tracked files and commit them in one step. If the modified file has never been committed to the repo, we’ll still need to use git add to track it first.</p>
<p>So let’s make a change to our example script from an earlier video and try out this new flag. We’ll now modify our main function and make it call the check reboot function that we wrote before. If a reboot is pending, we’ll print a message and then exit our program with an exit status of one. Since we’re using the sys module, we’ll need to import it. All right. Now that we’ve made the change, we’re ready to try out the new -a flag. We’ll also use the -m flag to add the commit message directly. This time, we’ll say that we’re calling check underscore reboot and exiting with one on the error condition.</p>
<p>These shortcuts are useful when making small changes that we know we’ll want to commit directly without keeping them in the staging area and having to write long and complex descriptions. Keep in mind that when you use the -m shortcut, you can only write short messages and can’t use the best practices regarding commit descriptions that we talked about earlier. So it’s best reserved for truly small changes that don’t require extra context or explanation, short and sweet.</p>
<p>Heads up, when you use the -a shortcut, you skip the staging area, meaning, you can’t add any other changes before creating the commit. So you need to be sure that you’ve already included everything you want to include in that commit.</p>
<p>In the end, using a shortcut like -a is just like using the regular commit workflow. The commit will show up in the log along with the message just as usual. Let’s check that out. See how our latest commit was added to the top of the list of commits and notice how the head indicator has now moved to the latest commit.</p>
<p>You might be wondering, what is this <em><strong>HEAD</strong></em> and where is it heading? We’ll keep coming across it. So let’s clarify. Git uses the head alias to represent the currently checked out snapshot of your project. This lets you know what the contents of your working directory should be. In this case, the current snapshot is the latest commit in the project. We’ll soon learn about branches. In that case, head can be a commit in a different branch of the project. We can even use git to go back in time and have head representing old commit from before the latest changes were applied. <em><strong>In all cases, HEAD is used to indicate what the currently checked out snapshot is</strong></em>. This is how git marks your place in the project. Think about it as a bookmark that you can use to keep track of where you are. Even if you have multiple books to read, the bookmark allows you to pick up right where you left off. When you run git commands like diff, branch, or status, git will use the head bookmark as a basis for whatever operation it’s performing. We’ll see Head used when we learn how to undo things and perform rollbacks. As a shortcut, it’s generally easy to think of head as a pointer to the current branch, although it can be more powerful than that.</p>
<h3 id="getting-more-information-about-our-changes">Getting More Information About Our Changes</h3>
<p>We’ve seen how <strong>git log</strong> shows us the list of commits made in the current Git repository. By default, it prints the commit message, the author, and the date of the change. This is useful, but if we’re combing through a history of changes in a repo to try and find what caused the latest outage, we’ll probably also need to look at the actual lines that changed in each commit.</p>
<p>To do this with git log, we can use the <strong>-p flag</strong>. The p comes from patch, because using this flag gives us the patch that was created. Let’s try it out. The format is equivalent to the diff-u output that we saw on an earlier video. It shows added lines with plusses and remove lines with dashes. Because the amount of text is now longer than what fits on your screen, Git automatically uses a paging tool that allows us to scroll using page up, page down, and the arrow keys. We still have one commit below the other, but now each commit takes up a different amount of space, depending on how many lines were added or removed in that commit. Using this option, we can quickly see what changes were made to the files in our repository. This can be especially useful if we’re trying to track down a change that recently broke our tools.</p>
<p>If we don’t want to scroll down until we find the commit that we’re actually interested in, another option is to use the <strong>git show</strong> command. This command takes a <em>commit ID as a parameter</em>, and will display the information about the commit and the associated patch. We’ll talk more about commit IDs in a later video. But for now, remember that this is an identifier that we see next to the word commit in the log. Let’s check this out by first listing the current commits in the repo and then calling git show for the second commit in the list. First, I’m going to exit out by pressing q. We’ve shown how we can use git log for listing commits, and git log -p for showing the associated patches.</p>
<p>Another interesting flag for git log is the <strong>–stat flag</strong>. This will cause git log to show some stats about the changes in the commit, like which files were changed and how many lines were added or removed. Let’s try it with our repo. There are a bunch of other options to git log, so we won’t cover them all. You can always use the reference documentation or the manual pages to find out more. And as we called up before, <em>you don’t need to memorize any of this, you’ll learn the different commands and flags by using them. The important thing to remember is that all the information is stored in the repository and you have it at your fingertips when you need it.</em> You’re welcome.</p>
<p>Now, what about changes that haven’t been committed yet? Until now, whenever we’ve made changes to our files, we’ve either added them to the staging area with git add and committed them with git commit, or committed them directly using git commit -a. This works fine, but it means we have to know exactly which changes we’ve made.</p>
<p>Sometimes it can take a while until we’re ready to commit. We call these commitment issues. Just kidding. But imagine you’ve been working on adding a new complex feature to a script and it requires thorough testing. Before committing it, you need to make sure that it works correctly. Check that all the test cases are covered and so on and so on. So while doing this you find bugs in your code that you need to fix. It’s only natural that by the time you get to the commit step you don’t really remember everything you changed. To help us keep track git gives us the <strong>git diff</strong> command.</p>
<p>Let’s make a new change to our all_checkcs.py script and then try this command out. We’ll add another message to the user to say that everything is okay when the check is successful and then exit with 0 instead of 1.</p>
<p>We’ve made the change. Let’s now save it and check out what git diff shows us. Again, this format is equivalent to the <strong>diff -u</strong> output that we saw earlier. In this case, we see that the only change is the extra lines that we’ve added. If our change was bigger and included several files, we could pass a file by parameter to see the differences relevant to that specific file instead of all the files at the same time.</p>
<p>Something else we can do to review changes before adding them is to use the <strong>-p flag</strong> with the <strong>git add</strong> command. When we use this flag, git will show us the change being added and ask us if we want to stage it or not. This way we can detect if there’s any changes that we don’t want to commit.</p>
<p>Let’s try that one out. We’ve staged our change and it’s now ready to be committed. If we call git diff again, it won’t show any differences, since git diff shows only unstaged changes by default. Instead, we can call <strong>git diff --staged</strong> to see the changes that are staged but not committed. With this command, we can see the actual stage changes before we call <strong>git commit</strong>. Let’s commit these changes now so that they aren’t pending anymore. We’ll say that we’ve added a message when everything’s okay.</p>
<p>Nice, and with that, we’ve learned a bunch of different ways to get more information about our changes.</p>
<h3 id="deleting-and-renaming-files">Deleting and Renaming Files</h3>
<p>Let’s say that you’ve decided to clean up some old scripts and want to remove them from your repository. Or you’ve done some refactoring, which makes that particular file, obsolete. You can remove files from your repository with the <strong>git rm</strong> command, which will stop the file from being tracked by git and remove it from the git directory.</p>
<p>File removals go through the same general workflow that we’ve seen. So you’ll need to write a commit message as to why you’ve deleted them.</p>
<p>What if you have a file that isn’t accurately named? This can happen. For example, if you start writing a script that you thought would only do one thing, and then expands to cover more use cases. Or conversely, if you named your script thinking that it would be very generic, but it ends up being more specific. You can use the <strong>git mv</strong> command to rename files in the repository.</p>
<p>The <strong>git mv</strong> command works in a similar way to the <strong>mv</strong> command on Linux and so can be used for both moving and renaming. If our repository included more directories in it, we can use the same <strong>git mv</strong> command to move files between directories.</p>
<p>As you can probably tell from our examples, the output of git status is a super useful tool to help us know what’s up with our files. It shows us which files have tracked or untracked changes, and which files were added, modified, deleted or renamed. It’s important that the output of these commands stays relevant to what we’re doing.</p>
<p>If we have a long list of untracked files, we might lose an important change in the <em>noise</em>. If there are files that get automatically generated by our scripts, or our operating system generates artifacts that we don’t want in our repo, we’ll want to <em>ignore</em> them so that they <em>don’t add noise</em> to the output of git status. To do this, we can use the <em><strong>.gitignore</strong></em> file. Inside this file, we’ll specify rules to tell git which files to skip for the current repo. This file needs to get tracked just like the rest of the files in the repo with <strong>git add</strong>.</p>
<h2 id="undoing-things">Undoing Things</h2>
<h3 id="undoing-changes-before-committing">Undoing Changes Before Committing</h3>
<p>Being able to <em>revert our changes is one of the most powerful features offered by version control systems</em>. There’s a bunch of different techniques available depending on which changes we need to undo. In this section and the next few coming up, we’ll talk about the most common ways to revert changes in Git and when to use each approach.</p>
<p>For example, you might find yourself in a situation where you’ve made a bunch of changes to a file but decide that you don’t want to keep them. You can change a file back to its earlier committed state by using the <strong>git checkout</strong> command followed by the name of the file you want to revert.</p>
<p>Speaking of, let’s try this out using our scripts repository. We’ll edit our all checks pi script and remove the check reboot function, then save and go back to the command line. Cool. We’ve made our change. Let’s try our script and see what happens.</p>
<p>By deleting that function, we’ve actually broke the script. Let’s see what git status has to say about this. As expected, we see that our file is modified and the changes aren’t staged yet. Check out how git gives us a couple helpful tips on what to do now. We can run <strong>git add</strong> to stage our changes or we can run <strong>git checkout</strong> to discard them. If you need help remembering what this command does, think of it this way, you’re checking out the original file from the latest storage snapshot. Let’s do that now</p>
<p>We’ll check out at the original file and then take a look at what git status has to say about it and finally retry our script. Looks like we have a typo. Let’s go back and fix it. Done and done.</p>
<p>With that, we’ve demonstrated how we can use <strong>git checkout</strong> to revert changes to modify files <em>before they get staged</em>. This command will <em>restore</em> the file to the latest storage snapshot, which can be either <em>committed</em> or <em>staged</em>. So if you’ve made additional changes to a file after you’ve staged it, you can restore the file to the earlier stage version.</p>
<p>If you need to check out individual changes instead of the whole file, you can do that using the <strong>-p flag</strong>. This will ask you change by change if you want to go back to the previous snapshot or not. That’s it for undoing unstaged changes.</p>
<p>What if you added the changes to the staging area already? If we realize we’ve added something to the staging area that we didn’t actually want to commit, we can unstage our changes by using the <strong>git reset</strong> command. Staging changes that we don’t actually intend to commit happens all the time. Especially if we use a command like <strong>git add *</strong>, where the star is a file glob pattern used in Bash that expands to all files.</p>
<p>This command will end up adding any change done in the working tree to the staging area. While sometimes that might be what we want, it can also lead to some surprises.</p>
<p>Let’s try it out with an example. First, we’ll pretend we’re trying to debug a problem in our script. For that, we create a temporary file with the output of our script. Then, we’ll add all unstaged changes in our working tree using git add <strong>*</strong>. Finally, check the status using <strong>git status</strong>. We can see that this output file, which was supposed to be a temporary file for debugging, has now been staged in our repo but we didn’t want to commit it. Conveniently, the <strong>git status</strong> command tells us how to unstage the file right there in the output. The example output mentions the head alias. Remember it’s the current checked out snapshot. So by running the suggested <strong>git reset</strong> command, we’re resetting our changes to whatever’s in the current snapshot. Let’s try it out. The file is once again untracked in our working tree and no longer staged. You can think of reset as the counterpart to add. With add, you can well add changes to the staging area. With reset, you remove changes from the staging area. You can use <strong>git reset -p</strong> to get git to ask you which specific changes you want to reset.</p>
<p>With that, we’ve seen how we can revert unstaged and stage changes. But what if you’ve already created a commit with the changes that you want to undo?</p>
<h3 id="amending-commits">Amending Commits</h3>
<p>In general, we try to make sure our commits include all the right changes and descriptions.</p>
<p>But we’re all human and we make mistakes. It’s not uncommon for developers and IT specialists to realize that there is an error in a recent commit, which is why it’s important to know how to take action and fix it.</p>
<p>Let’s say you just finished committing your latest batch of work, but you’ve forgotten to add a file that belongs to the same change. You’ll want to update the commit to include that change. Or maybe the files were correct, but you realize that your commit message just wasn’t descriptive enough. So you want to fix the description to add a link to the bug that you’re solving with that commit. What can you do?</p>
<p>We can solve problems like these using the <strong>–amend</strong> option of the <strong>git commit</strong> command. When we run <strong>git commit --amend</strong>, git will take whatever is currently in our staging area and run the git commit workflow to overwrite the previous commit. Let’s see this in an example. We’ll go to our scripts directory and create two new files using the touch command. Then list the contents of the directory using ls at our Python script and commit it saying that we’ve added two files. As you can see, the message printed by git says that only one file was added. Our commit message said that we added two files, but we forgot to add one of them. Ouch. Don’t panic. We can fix it. We’ll start by adding the missing file and then amending our commit. We call git commit --amend and an editor opened up showing the commit message and the stats about the commit that we’re working with. The list of added files for this commit now includes both files that we wanted to add. Yay. Now that the files have been added, we can also improve our initial commit message which was a bit too short. We’ll keep the existing description as the first sentence of our commit, and then add a line of description about the intended purpose of each file. With that, our commit is ready to be amended. Let’s save the new description as usual. We’ve amended our previous commit to include both files and a better message. You could also just update the message of the previous commit by running the git commit --amend command with no changes in the staging area.</p>
<p><em><strong>An important heads up</strong></em>. While <strong>git commit --amend</strong> is okay for fixing up <em>local commits</em>, <em><strong>you shouldn’t use it on public commits</strong></em>. Meaning, those that have been pushed to a public or shared repository. This is because using --amend rewrites the git history removing the previous commit and replacing it with the amended one. This can lead to some confusing situations when working with other people and should definitely be avoided. So remember, fixing up a local commit with amend is great and you can push it to a shared repository after you fixed it. But you should <strong>avoid amending commits that have already been made public</strong>.</p>
<p>We’ve covered how to fix staged and unstaged changes, and how to fix a commit that was incomplete. Up next, we’ll talk about what to do if you come across a bad commit that needs to be completely reverted.</p>
<h3 id="rollback">Rollback</h3>
<p>Fixing your work before you commit is good. But what happens if it’s already been snapshotted by Git?</p>
<p>Let’s say you host to Git repository on a company server that contains all kinds of useful automation scripts that you and your coworkers use. One morning before coffee, you make a few changes to one of these scripts and commit the updated files. A few hours later, you start to receive tickets from users indicating some part of the script is broken. From the errors they describe, it sounds like the problem is related to your recent changes.</p>
<p>Oh oh, you could look at the code you updated to see if you can spot the bug. But more tickets are pouring in and you want to fix the problem as fast as possible. You decided it’s time for a rollback.</p>
<p>There are a few ways to rollback commits in Git. For now, we’ll focus on using the <strong>git revert</strong> command. Git revert doesn’t just mean undo. Instead, it creates a commit that contains the inverse of all the changes made in the bad commit in order to cancel them out. For example, if a particular line was added in the bad commit, then in the reverted commit, the same line will be deleted. This way you get the effect of having undone the changes, but the history of the commits in the project remains consistent leaving a record of exactly what happened. So <strong>git revert</strong> will create <em>a new commit</em>, that is the opposite of everything in the given commit. We can revert the latest commit by using the <em>HEAD alias</em> that we mentioned before. Since we can think of HEAD as a pointer to the snapshot of your current commit, when we pass HEAD to the <strong>revert</strong> command we tell Git to rewind that current commit.</p>
<p>To check this out, we’ll first add a faulty commit to our example repo. We’ve added some code to our script. Let’s save and commit this. So now, our code is committed. We didn’t even test it which is a bad idea if you’re doing this for real. You might have already spotted the problem with our code. This is where users start filing tickets and saying that things are broken, and so we run our script to see what happens. Oops, we use the function that we forgot to define. It’s rollback time.</p>
<p>Let’s get rid of this faulty code by typing <strong>git revert head</strong>. So once we issue that git revert command, we’re presented with the text editor commit interface that we’ve all seen before. In this case, we can see that git has automatically added some text to the command indicating it’s a rollback. The first-line mentions that it’s reverting the commit we just did called Add call to disk full function. The extra description even includes the identifier of the commit that got reverted.</p>
<p>While we could use this description as is, <em>it’s usually a good idea to add an explanation of why we’re doing the rollback</em>. Remember that the goal of these descriptions is to help our future selves understand why things happen. In this case, we’ll explain that the reason for the rollback is that the code was calling a function that wasn’t defined. Once we’re done entering the description, we can exit and save as usual.</p>
<p>You’ll notice the output that we get from the git revert command looks like the output of the git commit command. This is because git revert creates a commit for us. Since a revert is a normal commit, we can see both the commit and the reverted commit in the log. Let’s look at the last two entries in the log using dash P and dash two as parameters. As demonstrated before, the <strong>-p</strong> parameter lets us see the patch created by the commit while the <strong>-2</strong> perimeter limits the output to the last two entries.</p>
<p>So in this log, we can see that when we called revert, git created a new commit that’s the inverse of the previous one. This removes the lines that we added in the previous commit. We can see that the original commit shows the lines we added by preceding them with a plus sign. The same line shows up with a minus sign in the newer commit message indicating that they were removed. Just like that, the bad commit is reverted and the error stopped. In this example, we reverted the latest commit in our tree. But what if we had to revert a commit that was done before that?</p>
<h3 id="identifying-a-commit">Identifying a Commit</h3>
<p>So far we’ve used the head alias to specify the most recently checked out commit in our Git history. In our bad snapshot example, the error also happened to be in the most recently created commit, but errors can sometimes take a while to be detected. And so, we might need to revert other commits farther back in time. We can target a specific commit by using its commit ID.</p>
<p>We’ve seen commit IDs a few times already. They show up when we’re running the git log command, and we also saw the commit ID of the reverted commit in our last example. Commit IDs are those complicated looking strings that appear after the word commit in the log messages. Let’s have a look at the latest log entry in our checks repo.</p>
<p>The commit ID is the 40 character long string after the word commit, you really can’t miss it. This long jumble of letters and numbers is actually something called a hash, which is calculated using an algorithm called <strong>SHA1</strong>. Essentially, what this algorithm does is take a bunch of data as input and produce a 40 character string from the data as the output. In the case of Git, the input is all information related to the commit, and the 40 character string is the commit ID. Cryptographic algorithms like SHA1 can be really complex, so we won’t go too deep into what this means. If you’re interested, you’ll find links to more information in the next reading. Still you might be wondering, why on earth would you use a long jumble of letters as an ID for commit, instead of incrementing an integer, like 123, etc?</p>
<p>To answer that, let’s take a quick look at the reason why Git uses a hash instead of a counter, and how that hash is computed. Although SHA1 is a part of the class of cryptographic hash functions, Git doesn’t really use these hashes for security. Instead, they’re used to guarantee the consistency of our repository. Having consistent data means that we get exactly what we expect. To quote Git’s creator, <em><strong>Linus Torvalds</strong></em>:</p>
<blockquote>
<p>“you can verify the data you get back out is the exact same data you put in”. <a href="https://www.youtube.com/watch?v=4XpnKHJAok8">Google Tech Talk: Linus Torvalds on git</a></p>
</blockquote>
<p>This is really useful in distributed systems like Git because everyone has their own repository and is transmitting their own pieces of data. Computing the hash keeps data consistent because it’s calculated from all the information that makes up a commit. The commit message, date, author, and the snapshot taken of the working tree. The chance of two different commits producing the same hash, commonly referred to as a collision, is extremely small. So small, it wouldn’t happen by chance. It’d take a lot of processing power to cause this to happen on purpose. If you use a hash to guarantee consistency, you can’t change anything in the Git commit without the SHA1 hash changing too.</p>
<p>Each time we amend a commit, the commit ID will change. This is why it’s important not to use dash dash amend on commits that have been made public. The data integrity offered by the commit ID means that if a bad disk or network link corrupt some data in your repository, or worse, if someone intentionally corrupt some data, Git can use the hash to spot that corruption. Aha, it will say, the data you’ve got isn’t the data you expected, something went wrong.</p>
<p>Okay, enough backstory. How can you use commit IDs to specify a particular commit to work with, like during a rollback?</p>
<p>Let’s look at the last two entries in our repo using the git log -2 command. Say we realized that we actually liked the previous name of our script, and so we want to revert this commit where we renamed it. First, let’s look at that specific commit using git show, which we mentioned in an earlier video. We’ve copied and pasted the commit ID that we wanted to display, and that works. Alternatively, we could provide just the first few characters identifying the commit to the command, and Git will be smart enough to guess which commit ID starts with those characters, as long as there’s only one matching possibility.</p>
<p>Let’s try this out. Two characters is not enough, but usually four to eight characters will be plenty. Okay, now that we’ve seen how we can identify the commit that we want to revert, let’s call the <strong>git revert command with this identifier</strong>. As usual, this will open an editor where we should add a reason for the rollback. In this case, we’ll say that the previous name was actually better. Hooray for flip-flopping.</p>
<p>As we called out before, when we generate the rollback, Git automatically includes the ID of the commit that we’re reverting. This is useful when looking at a repo with a complicated history that includes a lot of commits. Now, once we save and exit the commit message, Git will actually perform the rollback and generate a new commit with its own ID. See how before the name of our commit the revert command already shows the first eight characters of the commit ID? Let’s use git show to look at it. All right, we’ve managed to revert a commit that wasn’t the most recent one. Well done, time travelers.</p>
<p>Over the past several videos we’ve covered a bunch of ways to undo things in Git. Whether for unstaged changes, staged changes, amending commits, or rolling back changes. If anything still seems unclear, now’s a great time to practice these commands on your local computer, try things out, and come up with more examples of use cases you want to test. Up next, we’ve spun up a handy cheat sheet summarizing all the content we just covered.</p>
<h2 id="branching-and-merging">Branching and Merging</h2>
<h3 id="what-is-a-branch">What is a branch?</h3>
<p>Up until now, we’ve only briefly mentioned branches. You might have seen the text on branch master and commit messages, or you might remember that we talked about branches in the context of the head pointer.</p>
<p>Branches are an important part of the Git work flow. So what is a branch? What is it used for?</p>
<p>In Git, a branch at the most basic level is just a pointer to a particular commit. But more importantly, it represents an independent line of development in a project, of which the commit it points to is the latest link in a chain of developing history.</p>
<p>The default branch that Git creates for you when a new repository initialized is called <em><strong>master</strong></em>. All of our examples and development have taken place on this branch so far. <em>The master branch is commonly used to represent the known good state of a project</em>. When you want to develop a feature or try something new in your project, you can create a separate branch to do your work without worrying about messing up this current working state.</p>
<p><em>If this seems confusing, maybe an analogy will help. You can think of a Git project as an assignment your teacher gives you in a class. You do all your work on the assignment in a set of notebooks, each notebook representing a different branch. You use some notebooks to jot down rough drafts in experiments, but you keep one notebook the master branch, in a tidy state and you copy the polish versions of these drafts into it. No doodling in the master note book, please.</em></p>
<p>Branches make it really easy to experiment with new ideas or strategies and projects. When you want to add a feature or fix something, you can create a new branch and do your development there. You can merge back into the master branch, when you’ve got something you like, or discard your changes without negative impact if they don’t work out. In Git, branches are used all the time, as a part of the normal development workflow.</p>
<p>As an example, think back to the problematic commit we fixed in an earlier section. We added a call to the disk full function, but forgot to actually define the function. So we had to roll it back because our users we’re seeing errors. Knowing what we know now, we could have done that work on a separate branch, maybe called something like add disk full. In that case, we could have iterated on our code there until it was working correctly, without it effecting the master branch. Only after the code is ready to be deployed, we would merge those changes back into the master branch.</p>
<p>In the next few sections, we’ll look into how to create new branches and merge their content into the master branch. We’ll also go over what to do if you run into any scary merge conflicts. Heads up, this is about to get pretty complicated. So make sure that you follow all of our exercises along in your computer and keep practicing coming up with new ways of using branches and merging, until you’re comfortable with each of the steps we show.</p>
<h3 id="creating-new-branches">Creating new branches</h3>
<p>As branches are essential to how work is done in git, there’s tons of different ways to work with them. We can use the <strong>git branch</strong> command to <em>list, create, delete, and manipulate branches</em>.</p>
<p>Running <strong>git branch</strong> by itself will show you a list of all the branches in your repository. Let’s try it out in our checks repo. Our list is looking pretty empty right now, but don’t worry. Creating a branch is a snap. We do it by calling <strong>git branch</strong> with the <em>name of the new branch</em>. Let’s create a new feature branch and then list the branches again with git branch.</p>
<p>Our new branch was created based on the value of <strong>HEAD</strong>. Remember that <em>this might not necessarily be the master branch</em>. The list we get shows that we’re still on the master branch. We can tell because the current branch is indicated in the command’s output with an asterisk in a different color. We’ll look into other things that git branch lets us do with branches later on, but right now we want to switch to a new branch.</p>
<p>To do that, we’ll need to use the <strong>git checkout</strong> command. We saw earlier how we can use git checkout to restore a modified file back to the latest commit. Checking out branches is similar in that, the working tree is updated to match the selected branch including both the files and the git history. If this seems a bit confusing at first, you’re not alone. It might help to remember that <em><strong>we use git checkout to check out the latest snapshot for both files and for branches</strong></em>.</p>
<p>Let’s switch to our new feature branch by calling <strong>git checkout new-feature</strong>, and then listing our branches once again. Before we were working on the master branch but now that we’ve changed to our new branch, the star has moved to new feature. <em>Creating a branch and switching to it immediately is a pretty common task</em>. So common that git gives us a useful shortcut to create a new branch and to switch to it in a single command. We can use the git <strong>checkout -b new branch</strong> to do this. Take a look. See how the message says that we’ve switched to a new branch? Git created the new branch and switched to it in just one command. Super efficient.</p>
<p>Now that we have our shiny new branch, let’s create a new file in. We’ll create a new Python3 file, that will include the usual shebang line and empty main function and a call to that function. This file is empty because it’s only the beginning of our work. As it’s in a separate branch, it’s okay for it to not be finished yet. Let’s save our file and commit it to the current branch now. We’ve added a commit in this branch and it’s looking better.</p>
<p>Let’s check the last two entries in the log. We see the last two commits in this branch. Notice how next to the latest commit ID, git shows that this is where head is pointing to and that the branch is called even better feature. Next to the previous commit, git shows that both the master and the new feature branches are pointing to that snapshot of the project. In this way, we can see that the even better feature branch is ahead of the master branch.</p>
<p>With that, we’ve seen how we can create new branches and commit changes to them.</p>
<h3 id="working-with-branches">Working with Branches</h3>
<p>In our last section, we created a new branch different than the master branch and added a commit to it. Let’s check out the current status of our repo by calling <strong>git status</strong> and <strong>ls -l</strong>.</p>
<p>So we see that we’re on a clean working tree in the even better feature branch, and that a new free_memory.py file is in our working tree. Let’s now change back to the master branch using git checkout master and then lists the latest two commits there.</p>
<p>When we switch to a different branch using <strong>git checkout</strong>, under the hood, <em>git changes where HEAD is pointing</em>. Thanks to this checkout, HEAD went from pointing to the latest commit in the even better feature branch to the most recent commit of the master branch. The commit from even better feature doesn’t show up at all, and the latest snapshot is the second entry we’ve seen before. <strong>Remember</strong> that <em>when we switch branches, git will also change files in our working directory or working tree to whatever snapshot head is currently pointing at</em>.</p>
<p>Let’s look at the current contents of our directory. <a href="http://Free-memory.py">Free-memory.py</a> isn’t there. This demonstrates that when we switch branches in git, the working directory and commit history will be changed to reflect the snapshot of our project in that branch. When we check out a new branch and commit on it, those changes will be added to the history of that branch. Since <a href="http://free-memory.py">free-memory.py</a> was committed on another branch, it doesn’t show up in the history or working directory of the master branch.</p>
<p>One thing to note after all this back and forth, is that <em>each branch is just a pointer to a specific commit in a series of snapshots</em>. It’s very easy to create new branches because there isn’t any data that needs to be copied around. When we switch to another branch, we check out a different commit and git updates both HEAD and the contents of our working directory.</p>
<p>We’ve now seen how to create and switch between branches. So what if we want to delete a branch that we don’t need anymore?</p>
<p>We can do that by using <strong>git branch -d</strong>. Let’s first list the current branches in our repo and then get rid of the new feature branch by calling git branch -d new-feature. Just like that, our branch was trimmed. We can check with another call to git branch that is not there anymore. <em>If there are changes in the branch we want to delete that haven’t been merged back into the master branch, git will let us know with an error</em>. Hopefully, git also gives us the command to run if we were sure that we wanted to delete the branch, even if it has unmerged changes.</p>
<p>But we won’t do that just yet. We actually want to merge those changes back into the repo first. How do we do that?</p>
<h3 id="merging">Merging</h3>
<p>A typical workflow for managing branches in Git, is to create a separate branch for developing any new features or changes. Once the new feature’s in good shape, we <em>merge</em> the separate branch back into the main trunk of code.</p>
<p><strong>Merging</strong> is the term that Git uses for combining branch data and history together. We’ll use the <strong>git merge</strong> command, which lets us take the independent snapshots and history of one Git branch, and tangle them into another. Let’s try this out with our example branch from the last video.</p>
<p>First, will check that we’re in master branch, and then we’ll call git merge even-better-feature to merge the even-better-feature branch into the master branch. Now we’ve brought the master branch up to speed, which we can see by looking at the <strong>git log</strong>. As we’re on the master branch, HEAD points at master. We can see the even-better-feature and master branches are now both pointing at the same commit.</p>
<p>Git uses two different algorithms to perform a merge, <em>fast-forward</em> and <em>three-way merge</em>.</p>
<p>The merge we just performed is an example of a <em>fast-forward merge</em>. This kind of merge occurs when all the commits in the checked out branch are also in the branch that’s being merged. If this is the case, we can say that the commit history of both branches doesn’t diverge. In these cases, all Git has to do is update the pointers of the branches to the same commit, and no actual merging needs to take place.</p>
<p>On the other hand, a <em>three-way merge</em> is performed when the history of the merging branches has diverged in some way, and there isn’t a nice linear path to combine them via fast-forwarding. This happens when a commit is made on one branch after the point when both branches split. In our case, this could have happened if we made a commit on the master branch after creating the other branches. When this occurs, Git will tie the branch histories together with a new commit and merge the snapshots at the two branch tips with the most recent common ancestor, the commit before the divergence. To do this successfully, Git tries to figure out how to combine both snapshots.</p>
<ul>
<li>
<p>If the changes were made in different files, or in different parts of the same file, Git will take both changes and put them together in the result.</p>
</li>
<li>
<p>If instead the changes are made on the same part of the same file, Git won’t know how to merge those changes, and the attempt will result in a merge conflict. This sounds scary, but don’t panic. Git doesn’t quit, we’ll solve those conflicts in our next section.</p>
</li>
</ul>
<h3 id="merge-conflicts">Merge conflicts</h3>
<p>From time to time, we might find that both the branches we’re trying to merge have edits to the same part of the same file. This will result in something called a <em>merge conflict</em>.</p>
<p>Normally, Git can automatically merge files for us. But when we have a merge conflict, it will need a little help to figure out what to do.</p>
<p>To see how this would look, let’s edit the free_memory.py file in the master branch and replace the pass statement with a comment about what the main function should do. Cool, we made the change so let’s save it and commit it back to our master branch. Next, Let’s check out the even-better-feature branch and make a change in the same place. In this case, we will replace the call to pass with a call to print, saying that everything is okay. Now, we’ll save this other change and commit it to this branch. We are primed for chaos with our file all setup for a merge conflict. Let’s check out the master branch again and try to merge the even-better-feature back into it.</p>
<p>Git tells us it tried to automatically merge the two versions of the free memory file, but it didn’t know how to do it. We can use <strong>git status</strong> to get more information about what’s going on. As usual, <strong>git status</strong> gives us a lot of additional information:</p>
<ul>
<li>
<p>It tells us that we have files that are currently unmerged, and that we need to fix the conflicts or abort the merge if we decide it was a mistake.</p>
</li>
<li>
<p>It also tells us that we need to run Git add on each unmerged file to mark that the conflicts have been resolved. Let’s get to work.</p>
</li>
</ul>
<p>To fix the conflict, let’s open up free_memory.py in our text editor. Thankfully, Git has added some information to our files to tell us which parts of the code are conflicting. The unmerged content of the file at head, remember, in this case, head points to master, is the docstring stating what the main function should do. The unmerged content of the file in the even-better-feature branch is the call to the print function. It’s up to us to decide which one to keep or if we should change the contents of the file altogether. In this case, we’ll keep both statements and delete the merger markers.</p>
<p>Now that we’ve fixed the conflict, we’ll mark it as resolved by running git add on the file, and then call the git status to see how our merge is doing. See how Git now tells us that all conflicts have been resolved. Woo-hoo, we just need to call git commit to wrap up the merge.</p>
<p>The comments that git commit shows us look different than other commits. That’s because this is a merge and Git tells us so. It also tells us which file had conflicts which have now been resolved. The commit already has a description saying that it’s merging the other branch. This description was automatically created when we called the git merge command. But we can add onto this description if we want. For example, we can say that we’re keeping the lines from both branches, and then just save and exit as usual. The merge conflict is resolved.</p>
<p>To see what the commit history looks like now, we’ll use a couple of handy options to the <strong>git log</strong> command; <strong>–graph</strong> for seeing the commits as a graph, and <strong>–oneline</strong> to only see one line per commit. This format helps us better understand the history of our commits and how merges have occurred. We can see the new commit that was added and also the two separate commits that we merged. One coming from the master branch and the other coming from the even-better-feature branch. We can also see that master is pointing to the merge commit but even-better-feature is still pointing to the previous one.</p>
<p>In our example, resolving the conflict was straightforward and easy. But in the real world, this won’t always be the case. Merge conflicts can sometimes be tricky, complicated, and spread across multiple files. If you want to throw the merge away and start over, you can use the <strong>git merge --abort</strong> command as an escape hatch. This will stop the merge and reset the files in your working tree back to the previous commit before the merge ever happened.</p>
<p>So by now you know how to create, delete, and switch between branches in Git. You’ve also seen that each branch represents a pointer to a commit in a sequence of independent snapshots. You know how to merge these commits back into the main trunk by using the git merge command. Amazing work. Seriously, this isn’t easy stuff.</p>
<h2 id="working-with-remotes">Working with Remotes</h2>
<p>Up until now we’ve learned a lot of interesting and complex techniques on how to use Git locally. We started with the very basic Git workflow for modifying files staging the changes and then committing them. We then looked at other things we can do with Git, like deleting or renaming files, getting more information about commits or skipping the staging area altogether. Next, we saw how to undo staged, unstaged or committed changes in our Git repositories. Finally, we learned a bit about how to work with different branches, how to merge changes from separate branches. That’s a lot of complex stuff and it’s natural that it might seem scary. But it can also be very satisfying once you start to understand what’s going on and just think of how valuable these new skills will be as you advance your IT career.</p>
<p>In this module, we’ll learn a load of new things related to <strong>GitHub</strong> and remote repositories. We’ll first talk about what GitHub is and why it matters, and then we’ll dive into how to work with GitHub and other remote repositories. Being able to use remote repositories allows us to effectively collaborate with others. Our collaborators can be sitting in the same office as we are or they can be thousands of miles away on a different continent working at a different time of day. Using a version control system like Git lets us incorporate the work of different people no matter where they are or when they’re working.</p>
<h3 id="what-is-github">What is GitHub?</h3>
<p>We called out earlier that Git is a distributed version control system.</p>
<p><strong>Distributed</strong> means that each developer has a copy of the whole repository on their local machine. Each copy is a peer of the others. But we can host one of these copies on a server and then use it as a remote repository for the other copies. This lets us synchronize work between copies through this server.<br>
Any of us can create a Git server like this one, and many companies have similar internal services.</p>
<p>But if you don’t want to set up a Git server yourself and host your repositories, you can use an online service like GitHub. GitHub is a web-based Git repository hosting service. On top of the version control functionality of Git, GitHub includes extra features like bug tracking, wikis, and task management. GitHub lets us share and access repositories on the web and copy or clone them to our local computer, so we can work on them. GitHub is a popular choice with a robust feature set, but it’s not the only one. Other services that provide similar functionality are <strong>BitBucket</strong>, and <strong>GitLab</strong>. GitHub provides free access to a Git server for public and private repositories. It limits the number of contributors for the free private repositories, and offers an unlimited private repository service for a monthly fee. We’ll be using a free repository for our examples, which is fine for educational use, small personal projects, or open source development.</p>
<p><strong>A word of caution</strong> on how you can manage these repos though. If hackers get hold of information about your organization’s IT infrastructure, they can use it to try and break into your network. So make sure you treat this information as confidential. <em><strong>For real configuration and development work, you should use a secure and private Git server, and limit the people authorized to work on it</strong></em>.</p>
<p>To use GitHub, the first thing you need to do is create an account if you don’t have one already. Signing up online is free and relatively simple.</p>
<h3 id="basic-interaction-with-github">Basic Interaction with GitHub</h3>
<p>As we called out, GitHub is an online service. To use it, you first need to create an account on the site. Once you have your account, you’re ready to create your brand new repository on GitHub. Let’s do this now.</p>
<p>We’ll start by clicking the Create a repository link on the left. This will take us to the repo creation wizard. The wizard is pretty straightforward. The first thing we need to do is give a name for our repo. We’ll call this repo health checks. After that comes a description of what the repo will be used for. We’ll say that’ll be used for scripts that check the health of our computers. Then we need to select whether we want the repo to be public or private. We’ll go with private for now. Finally, the wizard can help us get started with some few initialization files like a README, a gitignore, or license file. We’ll go with just the README for now, and then create the repo. Yeah. Using the wizard, we created the repo and have a fresh remote repository ready to go. Just like magic. Let’s get to work.</p>
<p>First step is to create a local copy of the repository. We’ll do that by using the git clone command followed by the URL of the repo. GitHub conveniently lets us copy the URL from our repo from the interface so that we don’t have to type it. We’re now ready to clone the repo into our computer. We’ll do that by calling git clone and paste in the URL we copied. To do this, GitHub will ask for our username and password. Just like that, we’ve downloaded a copy of the remote repository from GitHub onto the local machine. This means that we can perform all the git actions that we’ve learned up till now. Since the repo is called health checks, a directory with that name was automatically created for us and now has the working tree of the Repository in it. So let’s change that directory and look at the contents. Our repo is basically empty. It only has the README file that GitHub created for us. This file is in a special format called <strong>markdown</strong>. Let’s add a bit more content to it. We’ve changed this file. We need to stage the change and committed. We’ve seen a couple of different ways to do that. Let’s use our shortcuts to do this in just one command.</p>
<p>We’ve modified our README file. But we’ve seen all this before. We got to remote repository set up on GitHub. So let’s use it. We can send our changes to that remote repository by using the <strong>git push</strong> command which will gather all the snapshots we’ve taken and send them to the remote repository. In this case, we’ve only taken one snapshot. To push our modified README up to GitHub, we’ll just call <strong>git push</strong>. Once again, we’re asked for our password. After that, we see a bunch of messages from git related to the push. When we access our project, we see the contents of the README file. So if we check our repository on GitHub, we should see the updated message.We’ve taken the local changes on our computer and pushed them out to a remote repository hosted on GitHub.</p>
<p>You’ve probably noticed that we had to enter our password both when retrieving the repo and when pushing changes to the repo. There are a couple ways to avoid having to do this. One way is to create an <strong>SSH key-pair</strong> and store the public key in our profile so that GitHub recognizes our computer. Another option is to use a <em>credential helper</em> which caches our credentials for a time window so that we don’t need to enter our password with every interaction. Git already comes with a credential helper baked in. We just need to enable it. We do that by calling <strong>git config --global credential.helper cache</strong>. Now that we’ve enabled the credential helper, we’ll need to enter our credentials once more. After that, they’ll be cached for 15 minutes. To check this, we can try another git command, <strong>git pull</strong> which is the command we use to retrieve new changes from the repository. We’ll enter our credentials on the first call to the command and they’ll be cached, so we won’t need to enter them again.</p>
<p>With that, we’ve seen how to create repositories on GitHub, clone our remote repository, push changes to it, and pull changes from it.</p>
<h3 id="what-is-a-remote">What is a remote?</h3>
<p>When we <em>clone</em> the newly created GitHub repository, we had our local Git Repo interact with a <em>remote repository</em>. Remote repositories are a big part of the distributed nature of Git collaboration.</p>
<p>It let lots of developers contribute to a project from their own workstations making changes to local copies of the project independently of one another. When they need to share their changes, they can issue git commands to pull code from a remote repository or push code into one. There are a bunch of ways to host remote repositories. As we called out, there is many internet-based Git hosting providers like GitHub, BitBucket or GitLab which offer similar services.</p>
<p>We can also set up a Git server on our own network to host private repositories. A locally hosted Git server can run on almost any platform including Linux, mac OS, or Windows. This has benefits like increased privacy, control, and customization.</p>
<p>To understand remote repositories, and Git’s distributed nature a bit better, imagine you’re working together with some friends to design a computer game, each of you has a different portion of the game you’re responsible for. One person is designing the levels, another the characters while others are writing the code for the graphics, physics, and gameplay. All these areas will have to come together into a single place for the final product. Although your friends might work on their parts by themselves, from time to time, everyone needs to send out progress updates to let each other know what they’ve been working on. You will then need to combine their work into your own portion of the project to make sure it’s all compatible.</p>
<p>Using Git to manage a project helps us collaborate successfully. Everyone will develop their piece of the project independently in their own local repositories maybe even using separate branches. Occasionally they’ll push finished code into a central remote repository where others can pull it and incorporate it into their new developments. So how does this work?</p>
<p>Alongside the local development branches like master, Git keeps copies of the commits that have been submitted to the remote repository and separate branches.</p>
<ul>
<li>
<p>If someone has updated a repository since the last time you synchronize your local copy, Git will tell you that it’s time to do an update.</p>
</li>
<li>
<p>If you have your own local changes when you pull down the code from the remote repo, you might need to fix merge conflicts before you can push your own changes.</p>
</li>
</ul>
<p>In this way Git let’s multiple people work on the same project at the same time. When pulling new code it will merge the changes automatically if possible or will tell us to manually perform the integrating if there are conflicts. So when working with remotes the workflow for making changes has some extra steps. We will still <em>modify</em>, <em>stage</em> and <em>commit</em> our local changes. After committing, we’ll <em>fetch</em> any new changes from the remote repo, manually <em>merge</em> if necessary, and only then will <em>push</em> our changes to the remote repo.</p>
<p>Git supports a variety of ways to connect to a remote repository. Some of the most common are using the HTTP, HTTPS and SSH protocols and their corresponding URLs. HTTP is generally used to allow read only access to a repository. In other words, it lets people clone the contents of your repo without letting them push new contents to it. Conversely HTTPS and SSH, both provide methods of authenticating users so you can control who gets permission to push.</p>
<p>The distributed nature of the work means that there are no limits to how many people can push code into a repository. It’s a good idea to control who can push codes to repos and to make sure you give access only to people you trust. Web services like GitHub, offer a bunch of different mechanisms to control access to Repositories. Some of these are available to the general public while others are only available to enterprise users. By now you have an idea of what a remote repository is and how it interacts with local Git repositories.</p>
<h3 id="working-with-remotes-1">Working with remotes</h3>
<p>When we call a git clone to get a local copy of a remote repository, Git sets up that remote repository with the default <em>origin</em> name. We can look at the configuration for that remote by running <strong>git remote -v</strong> in the directory of the repo. Here we see the URLs associated with the origin remote.</p>
<p>There are two URLs. One will be used to fetch data from the remote repository, and the other one to push data to that remote repo. They’ll usually point at the same place. But in some cases, you can have the fetch URL use HTTP for read only access, and the push URL use HTTPS or SSH for access control. This is fine as long as the contents of the repo that you read when fetching are the same that you write to in pushing.</p>
<p>Remote repositories have a name assigned to them, by default, the assigned name is origin. This lets us track more than one remote in the same Git directory. While this is not the typical usage, it can be useful when collaborating with different teams on projects that are related to each other.</p>
<p>If we want to get even more information about our remote, we can call <strong>git remote show origin</strong>. There’s a ton of information here, and we don’t need all of it right now. We can see the fetch and push URLs that we saw before, and the local and remote branches too. For now we only have a master branch that exists locally and remotely. So the information here seems a bit repetitive. Once you start having more branches, especially different branches in the local and remote repo, this information starts becoming more complex.</p>
<p>So what are these remote branches that we’re talking about anyways? Whenever we’re operating with remotes, Git uses remote branches to keep copies of the data that’s stored in the remote repository. We could have a look at the remote branches that our Git repo is currently tracking by running <strong>git branch -r</strong>. These branches are read only. We can look at the commit history, like we would with local branches, but we can’t make any changes to them directly. To modify their contents, we’ll have to go through the workflow we called out before. First, we pull any new changes to our local branch, then merge them with our changes and push our changes to the repo.</p>
<p>We can also use <strong>git status</strong> to check the status of our changes in remote branches as well. Now that we’re working with a remote repository, <strong>git status</strong> gives us additional information. It tells us that our branch is up to date with the origin/master branch, which means that the master branch in the remote repository called origin, has the same commits as our local master branch. But what if it wasn’t up to date?</p>
<h3 id="fetching-new-changes">Fetching New Changes</h3>
<p>While we were learning about remotes, our colleague Blue Kale added some files to our repo. We could always use the GitHub website to browse the changes that were submitted. But we want to learn how to do it by interacting through the command line because you might need to do it this way at your job, and it’ll work the same no matter which platform you use to interact with Git.</p>
<p>So first, let’s look at the output of the <strong>git remote show origin</strong> command. Check out how it says that the local branches out of date. This happens when there were commits done to the repo that aren’t yet reflected locally. Git doesn’t keep remote and local branches in sync automatically, it waits until we execute commands to move data around when we’re ready.</p>
<p>To sync the data, we use the <strong>git fetch</strong> command. This command copies the commits done in the remote repository to the remote branches, so we can see what other people have committed. Let’s call it now and see what happens. Fetched content is downloaded to the remote branches on our repository. So it’s not automatically mirrored to our local branches. We can run <strong>git checkout</strong> on these branches to see the working tree, and we can run <strong>git log</strong> to see the commit history. Let’s look at the current commits in the remote repo by running <strong>git log origin/master</strong>. Looking at this output, we can see that the remote origin/branch is pointing to the latest commit, while the local master branch is pointing to the previous commit we made earlier on. Let’s see what happens if we run git status now. Git status helpfully tells us that there’s a commit that we don’t have in our branch. It does this by letting us know our branches behind their remote origin/master branch.</p>
<p>If we want to integrate the branches into our master branch, we can perform a merge operation, which merges the origin/master branch into our local master branch. To do that, we’ll call <strong>git merge origin/master</strong>. Great. We’ve merged the changes of the master branch of the remote repository into our local branch. See how Git tells us that the code was integrated using fast-forward? It also shows that two files were added, all_checks.py and disk_usage.py. If we look at the log output on our branch now, we should see the new commit. We see that now our master branch is up to date with the remote origin/master branch. With that, we’ve updated our branch to the latest changes. We can use <strong>git fetch</strong> like this to review the changes that happen in the remote repository. If we’re happy with them, we can use <strong>git merge</strong> to integrate them into the local branch. Fetching commits from a remote repository and merging them into your local repository is such a common operation in Git that there’s a handy command to let us do it all in one action.</p>
<h3 id="updating-the-local-repository">Updating the Local Repository</h3>
<p>Earlier, we took a look at the basic workflow for working with remotes when we want to fetch the changes manually, merge if necessary, and only then push any changes of our own. Since fetching and merging are so common, Git gives us the <strong>git pull</strong> command that does both for us. Running <strong>git pull</strong> will fetch the remote copy of the current branch and automatically try to merge it into the current local branch. Let’s check if our friend Blue Kale has made any new changes to the repo. We’ll run <strong>git pull</strong> and see what changes we get.</p>
<p>If you look closely at this output, you’ll see that it includes the <em>output of the fetch and merge</em> commands that we saw earlier. First, Git fetched the updated contents from the remote repository, including a new branch. And then it did a fast forward merge to the local master branch. We’ll see that the all_checks file was updated as well. We can look at the changes by using <strong>git log -p -1</strong>. We see that our colleague added a check_disk_full function that includes the code from the other disk_usage.py file that we saw earlier.</p>
<p>When we called <strong>git pull</strong>, we saw that there was also a new remote branch called experimental. Our friend Blue Kale told us that they’ve started working on a new feature in that branch. Let’s check out the output of git remote show origin and see what it says about that new branch. We see that there’s a new remote branch called experimental, which we don’t have a local branch for yet. To create a local branch for it, we can run <strong>git checkout</strong> experimental. When we checkedout the experimental branch, Git automatically copied the contents of the remote branch into the local branch. The working tree has been updated to the contents of the experimental branch. Now we’re all set to work on the experimental feature together with our colleague.</p>
<p>In this last example, we got the contents of the experimental bunch together with those of the master branch when we called <strong>git pull</strong>, which also merged new changes onto the master branch. If we want to get the contents of remote branches without automatically merging any contents into the local branches, we can call <strong>git remote update</strong>. This will <em>fetch</em> the contents of all remote branches, so that we can just call <em>checkout</em> or <em>merge</em> as needed.</p>
<p>We’ve now seen a bunch of different ways that we can use to interact with remote repositories. We’ve seen how to check their status, how to push and pull changes into repositories, and even how to get new branches out of them.</p>
<p>(You can also see more in the video <a href="https://www.coursera.org/learn/it-security/item/P1I8z">Cryptography in Action</a> from the course <a href="https://www.coursera.org/learn/it-security/home/welcome">IT Security: Defense against the digital dark arts</a>.)</p>
<h2 id="solving-conflicts">Solving Conflicts</h2>
<h3 id="the-pull-merge-push-workflow">The Pull-Merge-Push Workflow</h3>
<p>We’ve now looked at the details of fetching and pulling data from a remote repositories without any local changes. We saw earlier how we can use the git push command to send our changes to the remote repo. But what if when we go to push our changes, there are new changes to the remote repo?</p>
<p>To find out, let’s start by making a change to our all_checks.py script. Remember way back to the beginning of the course, when we fixed the bug in the function that checks the disk space? The one that was doing gigabyte conversion twice? Part of the reason why our code was so buggy, was that we were passing numbers around without saying what those numbers were for. We could have made our code clearer by renaming our min_absolute parameter to min_gb. So that it’s obvious that the function expects gigabytes. With that, we’ve clarified the code of the function. Another way we can make the code invocation clearer, we can use the name of the parameters in the call to the function. By using the names of the parameters, our invocation is clear, and we can even alter the order of the values and our code would still work.</p>
<p>All right, we’ve made the change. Let’s stage it and commit it as usual. We’ll first use <strong>git add -p</strong> to look at the changes we made and accept them. Then we’ll create a commit message to show that we’ve renamed min absolute to min_ gb, and that we’re using parameter names for the invocation. We’ve made our change, staged it, and committed it.We should be ready to push into the remote repo, except now we have a collaborator also making changes. Let’s see what happens when we try running git push.</p>
<p>And it failed. Can you work out what went wrong here? There are a few hints. When we tried to push, Git rejected our change, that’s because the remote repository contains changes that we don’t have in our local branch that Git can’t fast-forward. As usual, Git gives us some helpful information along with the error message, especially the part about integrating remote changes with <strong>git pull</strong>. This means we need to sync our local remote branch with the remote repository before we can push. We learned earlier that we can do this with <strong>git pull</strong>. Let’s do this now. Git tried to automatically merge the local and remote changes to all_checks.py, but found a conflict.</p>
<p>Let’s first look at the tree of commits on all branches as represented by <strong>git log --graph --oneline --all</strong>. This graph shows us the different commits and positions in the tree. We can see the master branch, the origin/master branch, and the experimental branch. The graph indicates that our current commit and the commit in the origin/master branch share a common ancestor, but they don’t follow one another. This means that we’ll need to do a <em>three-way merge</em>.</p>
<p>To do this, let’s look at the actual changes in that commit by running <strong>git log -p origin/master</strong>. So our colleague decide to reorder the conditional clauses in the function to match the order that the parameters are passed to the function. They happen to change in the same line that we changed when we renamed the min_gb variable, which caused the conflict that Git couldn’t resolve.</p>
<p>Let’s fix it by editing the file to remove the conflict. We see that the problem occurred in the conditional. On the first line, we see our change, where min_absolute was renamed to min_gb. In the second line, we see the old variable names, with the checks done in a different order. We need to decide what to do to this. For example, we can keep the new order, but use min_gb. One thing to notice is that <em>Git will try to do all possible automatic merges</em> and only leave manual conflicts for us to resolve when the automatic merge fails.</p>
<p>In this case, we can see that the other changes we made were merged successfully without intervention. Only the change that happened in the same line of the file needed our input. We fixed the conflict here, and the file is short enough that we can very quickly check that there are no other conflicts. For larger files, it might make sense to search for the <em>conflict markers</em>, &gt;&gt;&gt;, in the whole file. This lets us check that there are no unresolved conflicts left.</p>
<p>Nice, now that we fixed the conflict, you can finish the merge. We need to <strong>add</strong> the all_checks.py file, and then call <strong>git commit</strong> to finish the merge. But first, we’re going to save and close. The editor message shows that it’s performing a merge of the remote branch with the local branch. We can add extra information to this message. For example, we can say that we fixed the conditional in the check_disk_usage function to use the new variable name and the new order.</p>
<p>Our merge is finally ready, we can try pushing to the remote again. Yes, after fixing the conflict, we were able to push our work to the remote repo. Let’s look at the commit history of the master branch now, by calling <strong>git log --graph --oneline</strong>. We see that the latest commit is the merge, followed by the two commits that caused the merge conflict, which are on split paths in our graph. As we called out before, when Git needs to do a three-way merge, we end up with a separate commit for merging the branches back into the main tree.</p>
<p>Now we know how to successfully complete a <em>pull</em>, <em>merge</em>, and <em>push</em> <em>cycle</em>, even when it means doing some manual merges.</p>
<p>This was a complex exercise, and it’s okay if some things still seem a bit scary. We all felt panic the first time we encountered a merge conflict. But don’t worry, it gets easier with practice. To practice dealing with merge conflicts, you want to have two copies of your repository in separate directories, then try editing the same lines of the same files. You can follow along with the examples shown here, or come up with your own. Up next, we’ll talk about using branches with a remote repositories.</p>
<h3 id="pushing-remote-branches">Pushing Remote Branches</h3>
<p>As we called up before, when using Git to work on a <em>new feature</em> or a <em>big refactor</em> of some kind, it’s recommended best practice to create separate branches. There are many advantages to doing this.</p>
<ul>
<li>
<p>For example, it might take you a while to finish a new feature and in the meantime, there could be a critical bug that needs fixing in the main branch of the code. By having separate branches, you can fix the bug in the main branch, release a new version and then go back to working on your feature without having to integrate your code before it’s ready.</p>
</li>
<li>
<p>Another advantage of working in separate branches is that you could even release two or more versions out of the same tree. One being the stable version and the other being the beta version. That way, any disruptive changes can be tested on a few users or computers before they’re fully released.</p>
</li>
</ul>
<p>So let’s start a new branch to work on a small refactor of our code. You could create the branch first, and then check it out or we can just create it and check it out with <strong>git checkout-b and the new branch name</strong>. We’re ready to start working on our refactor. Let’s open up the file, and have a look at it.</p>
<p>We’ve noticed there’s a <em>pattern of repeating code</em> in our all_checks.py script. For each check that we call, we check if it returns true or false. When it returns true, we print an error and exit. If we add a new check, we’ll have to repeat this pattern again.</p>
<p>On top of the repeated pattern, if a computer has more than one problem, only the error for the first one will be printed. So let’s <em>refactor</em> our code to <em>avoid the duplication</em> and <em>print all relevant errors</em>. We’ll do it step-by-step making each commit self-contained.</p>
<ul>
<li>
<p>The first thing we’ll do is create a function that checks if the disk is full without any parameters so it matches the pattern. This new wrapper function will pass the right parameters for us. Then we’ll change the code to call this function instead. We’ll also change the error message to something more accurate. We’ve changed the function, let’s save and test our code. Awesome, it’s working. Let’s commit the change. We’re ready for the next step in our refactor.</p>
</li>
<li>
<p>To <em>avoid code repetition</em>, we’ll create a <em>list containing the names of the functions that we want to call</em>, and then message to print if the function succeeds. After that, we’ll add a for loop that iterates over the list of checks and messages. Then we’ll call check, and if the return value is true, print the message and exit with an error code of one. After doing that we can delete the old code that we’ve already replaced. With this change made, let’s save once again and tests that our script still runs. Yes, it’s still working. Let’s commit the new change. By now, we’ve re-factored our code to avoid code duplication. The current code does the same as the old code. Once we’re ready to add new checks, we can do that by adding the function name and error message to the list of checks.</p>
</li>
<li>
<p>The last change that we want to do is to let our script show more than one message if more than one check is failing. To do that, we add a Boolean variable called “Everything Ok” before the iteration. Changes variable to false if one of the checks finds a problem, and then exit with an error code only after having done all the checks. All right, one last time. Let’s save and test to see if this works. Let’s now do a file commit for this change.</p>
</li>
</ul>
<p>With that, we have three commits and our refactor branch. Before we merge any of this into the master branch, we want to push this into the remote repo, so that our collaborators can view the code, test it, and let us know if it’s ready for merging. The first time we push a branch to a remote repo, we need to add a few more parameters to the <strong>git push</strong> command. We’ll need to add the <strong>-u</strong> flag to create the branch upstream, which is another way of referring to remote repositories. We’ll also have to say that <em>we want to push this to the origin repo, and that we’re pushing the refactor branch</em>.</p>
<p>Whoa, that’s a lot of information that Git’s giving us. It’s telling us if we want, we can create a pull request. We’ll talk more about pull requests later on. For now, we’re happy to see that new refactor branch has been created in the remote repo, which is what we wanted. This was a super complex example that incorporated a lot of concepts that we’ve learned about in this course, and also carried out some interesting Python concepts.</p>
<p>So now that our branch is pushed to the remote repo, it can be reviewed by our collaborators. Assuming they say it’s okay, how should this branch get merged back into the master branch?</p>
<h3 id="rebasing-your-changes">Rebasing Your Changes</h3>
<p>In our last section, we mentioned that once our branch has been properly reviewed and tested, it can get merged back into the master branch. This can be done by us or by someone else.</p>
<ul>
<li>
<p>One option is to use the git merge command that we discussed earlier.</p>
</li>
<li>
<p>Another option is to use the git rebase command. Rebasing means changing the base commit that’s used for our branch. To understand what this means, let’s quickly recap what we’ve learned about merges up till now.</p>
</li>
</ul>
<p>As we’ve seen in a lot of our earlier examples, when we create a branch at a certain point in the repo’s history, Git knows the latest commit that was submitted on both branches. If only one of the branches has new changes when we try to merge them, Git will be able to <em>fast forward</em> and apply the changes. But if both branches have new changes when we try to merge, Git will create a new merge commit for the <em>three-way merge</em>.</p>
<p>The problem with three way merges is that because of the split history, it’s hard for us to debug when an issue is found in our code, and we need to understand where the problem was introduced. By changing the base where our commits split from the branch history, we can replay the new commits on top of the new base. <em>This allows Git to do a fast forward merge and keep history linear</em>.</p>
<p>So how do we do it? We run the command <strong>git rebase</strong>, followed by the <em>branch</em> that we want to set as the new base. When we do this, Git will try to replay our commits after the latest commit in that branch. This will work automatically if the changes are made in different parts of the files, but will require manual intervention if the changes were made in other files. Let’s check out this process by rebasing our refactor branch onto the master branch.</p>
<p>First, we’ll <em>check out</em> the master branch and <em>pull</em> the latest changes in the remote repo. Git tells us that it’s updated the master branch with some changes that our colleague had made. At this point, the changes that we have in the refactor branch can no longer be merged through fast forwarding into the master branch. That’s because there’s now an extra commit in the master that’s not present in the refactor. Let’s see how this looks by asking the log command to show us the current graph of all branches. It might take a bit to follow everything that’s going on with this graph. But it can be really useful to understand complex history trees. As you can see, the refactor branch has three commits before the common ancestor, with the current commit that’s at the head of the master branch. If we merged our branch now, it would cause a three way merge. But we want to keep our history linear.</p>
<p>We’ll do this with a rebase of the refactor against master. As usual, Git gives us a bunch of helpful information. It says that it rewound head and replayed our work on top of it. And luckily, everything succeeded. Let’s look at the output of <strong>git log --graph --oneline</strong> for our branch right now. Now we can see the master branch and linear history with our list of commits. We’re ready to merge our commits back onto the main trunk of our repo and have this fast forwarded. To do that, we’ll <em>check out the master branch and merge the refactor branch</em>. Awesome, we were able to merge our branch through a fast forward merge and keep our history linear. We’re now done with our refactor and can get rid of that branch, both remotely and locally.</p>
<p>To remove the remote branch, we’ll call <strong>git push --delete origin refactor</strong>. To remove the local branch, we’ll call <strong>git branch -d refactor</strong>. Yes, we’re done with our refactor. We can now push changes back into the remote repo.</p>
<p>All right, we’ve just gone through an example using the <strong>git rebase</strong> command. We had a feature branch created against an older commit from master. So we rebased our feature branch against the latest commit from master and then merged the feature branch back into master. That was a complicated exercise. So if you’re still confused about what’s going on, take your time to review, and maybe come up with your own examples when you’d use a rebase.</p>
<blockquote>
<p><em><strong>git rebase refactor</strong></em> moves the current branch on top of the refactor branch</p>
</blockquote>
<h3 id="another-rebasing-example">Another Rebasing Example</h3>
<p>In our last section, we looked at an example use case for git rebase, where we used it to rebase a feature branch so that it could be cleanly integrated. There are many other possible uses of rebase.</p>
<p>One common example is to rebase the changes in the master branch when someone else also made changes and we want to keep history linear. This is a pretty common occurrence when you’re working on a change that’s small enough not to need a separate branch and your collaborators just happened to commit something at the same time. Let’s check out how this would work in practice.</p>
<p>First, we’ll make a change to our script. Now that we’ve made it easy to add new checks, will add a check to warn when there’s no working network. There’s a ton of things to check for this but for now we’ll keep it simple and just check whether we can resolve the <a href="http://google.com">google.com</a> URL. To do this, we’ll use the socket module. We’ll add a new function called check no network that will return true if it fails to resolve the URL and false if it succeeds. This socket.gethostbyname function raises an exception on failure. So we’ll use it try except block to wrap the call to the function and return false when the call succeeds or true when it fails. With this new function defined, we can now add the check to our list of checks. We’ll just add the name of the function and the message will be, “No working network.” We’ve made the change, let’s save it and commit it. Once more we’ll use the <strong>git commit -a</strong> shortcut and pass a message saying that we’ve added a simple network connectivity check. We want to check if one of our teammates also made a change in the master branch while we were working on our change.</p>
<p>In an earlier section, we showed how to do that by running <strong>git pull</strong> which will <em>automatically create a three-way merge if necessary</em>. In this example, we want to look at a different approach to <em>keep our project history linear</em>. So we’ll start by calling <strong>git fetch</strong> which you might remember we’ll put the latest changes into the <em>origin/master branch</em> but we won’t apply them to our local master branch. We see that we fetched some new changes. This means that if we tried to merge our changes, we end up with a three-way merge. Instead, we’ll now run <strong>git rebase</strong> against our <em>origin/master</em> to rebase our changes against those made by our colleague and keep history linear.</p>
<p>We’ve got a conflict and we’ll need to fix it. Git is giving us a lot of info on what it tried to do including what worked, what didn’t work and what we can do about it. Since we asked it to rebase, it tried to rewind our changes and apply them on top of what was in the origin/master branch. The first commit made by our colleague, renamed all_checks.py to health_checks.py. Git detected this and automatically merged our changes into the new file name. But when trying to merge our changes with the changes made by our colleague in the file, there was a merge conflict. The output gives us a bunch of instructions on how to solve this. We could fix the conflict, skip the conflicting commit or even abort the rebased completely. In this example, we want to fix the conflict. So let’s do that.</p>
<p>We’ll start by looking at the current state of the health_checks.py file. We see that while we were adding the connectivity check, our colleague was adding a check for the CPU being constrained. We want both functions and the end result. So let’s remove the conflict markers, cleaning up our file. This looks good. Let’s save and test our script out. So close it looks like our colleague forgot to import the <em>psutil</em> module. Let’s do that now. Let’s hope this works. We fixed the conflict and our script is working again. We now need to add the changes made to the health_checks.py file and continue with the rebase.</p>
<p>Now, the rebase has finished successfully let’s check out the output of <strong>git log --graph --oneline</strong> to see what the history looks like at this point. We see that we’ve applied our change on top of the other changes without needing a three-way merge. What we did just now to resolve the conflict is very similar to what we did earlier to merge our changes. The difference is, that the commit history ended up being linear instead of branching out. We’re now ready to push our new check to the remote repo.</p>
<p>In this example, we’ve seen how we can use the <em><strong>fetch rebase push workflow</strong></em> to merge our changes with our collaborators changes while keeping the history of our changes linear. As we called out, keeping history linear helps with debugging especially when we’re trying to identify which commit first introduced a problem in our project. We’ve now seen two examples of how to use the git rebase command. <em>One for merging feature branches back into the main trunk of our code and one for making sure that our commits made in the master branch apply cleanly on top of the current state of the master branch</em> and it doesn’t stop there. We can also use <strong>git rebase</strong> to change the order of the commits or even squash two commits into one. This is a very powerful tool but don’t worry you don’t need to memorize all of its possible uses you’ll learn them as you need them.</p>
<h3 id="best-practices-for-collaboration">Best Practices for Collaboration</h3>
<p>Over the past few sections, we’ve looked at a lot of things we can do with Git and remote repositories. It’s worth spending some time talking about best practices for collaborating with others.</p>
<ul>
<li>
<p>It’s a good idea to <strong>always synchronize your branches before starting any work on your own</strong>. That way, whenever you start changing code, you know that you’re starting from the most recent version and you minimize the chances of conflicts or the need for rebasing.</p>
</li>
<li>
<p>Another common practice is to try and <strong>avoid having very large changes that modify a lot of different things</strong>. Instead, try to make changes as small as possible as long as they’re self-contained. For example, if you are renaming a variable for clarity reasons, you don’t want to have code that adds new functionality in the same commit. It’s better if you split it into different commit. This makes it easier to understand what’s going on with each commit. On top of that, if you remember to push your changes often and pull before doing any work, you reduce the chances of getting conflict.</p>
</li>
<li>
<p>We called out already that <strong>when working on a big change, it makes sense to have a separate feature branch</strong>. This lets you work on new changes while still enabling you to fix bugs in the other branch. To make the final merge of the feature branch easier, it makes sense to regularly merge changes made on the master branch back onto the feature branch. This way, we won’t end up with a huge number of merge conflicts when the final merge time comes around.</p>
</li>
<li>
<p><strong>If you need to maintain more than one version of a project at the same time, it’s common practice to have the latest version of the project in the master branch and a stable version of the project on a separate branch</strong>. You’ll merge your changes into the separate branch whenever you declare a stable release. When using these two branches, some bug fixes for the stable version may be done directly on the stable branch if they aren’t relevant to the latest version anymore.</p>
</li>
<li>
<p>In the last couple of sections, we looked at how we can use rebase to make sure our history is linear. Rebasing can help a lot with identifying bugs, but use it with caution. Whenever we do a rebase, we’re rewriting the history of our branch. The old commits get replaced with new commits, so they’ll be based on different snapshots than the ones we had before and they’ll have completely different hash sums. This works fine for local changes, but can cause a lot of trouble for changes that have been published and downloaded by other collaborators. So as <strong>a general rule, you shouldn’t rebase changes that have been pushed to remote repos</strong>. The Git server will automatically reject pushes that attempt to rewrite the history of the branch. It’s possible to force Git to accept the change, but it’s not a great idea unless you really know what the implications will be. In our feature branch example, we rebased the branch, merged it to the master and then deleted the old one. That way, we didn’t push the rebase changes to the refactor branch, only to the master branch that hadn’t seen those changes before.</p>
</li>
<li>
<p>Early in our Git journey, we mentioned that <strong>having good commit messages is important</strong>. It’s already important when you’re working alone since good commit messages help the future you understand what’s going on, but it’s even more important when you’re collaborating with others since it gives your collaborators more context on why you made the change and can help them understand how to solve conflicts when necessary. So commit to being a good collaborator and remember to add those commit messages.</p>
</li>
</ul>
<p>Whenever we collaborate with others, there’s bound to be some merge conflicts and they can sure be a pain. I’ve definitely been frustrated when encountering complex merge conflicts and trying to debug the results. If I’m dealing with this type of merge conflict, my <strong>first step is to work backward and disable everything I’ve done and then see if the source still works, then I slowly add pieces of code until I hit the problem</strong>. That usually gets me through the tough times and has definitely highlighted some weird occurrences.</p>
<h3 id="module-3-review">Module 3 Review</h3>
<p>Before we start, congratulations on making it all the way here. We’ve covered some complex subjects and you’re showing a lot of dedication by making it to this point. Let’s review what we’ve learned in the last few sections about working with remote in Git.</p>
<ol>
<li>
<p>First, we talked about what GitHub is and what the basic interaction with the service looks like.</p>
</li>
<li>
<p>Then we discussed how remote repositories and the distributed nature of Git lets lots of contributors develop a project independently, and at the same time.</p>
</li>
<li>
<p>We then learned how to pull data down from remote repositories, push our local changes to them, and also resolve conflicts that pop-up when our local and remote branches are out of sync.</p>
</li>
<li>
<p>We wrapped up by looking at a complex example of using a feature branch for a refactor of our code and using rebase to make sure that our history stayed linear. That was a lot of info and you might be feeling a bit overwhelmed. It’s okay to feel that way. Learning how to use a VCS like Git can be difficult but the rewards are worth the effort. Remember that version control systems give you access to the history of any scripting project, fostering collaboration, and accountability, and making it possible to do fast rollbacks. Using and understanding of VCS is a valuable and versatile skill for every IT specialist and one that will set you apart from the crowd.</p>
</li>
</ol>
<h2 id="collaboration">Collaboration</h2>
<h3 id="intro-to-collaboration">Intro to Collaboration</h3>
<p>Over the past modules, we’ve learned a whole about how to interact with Git. We’ve covered how to use it both locally and remotely. We’ve seen how to rollback bad changes, solve conflicts when collaborating with others, and a bunch of other little nifty things.</p>
<p>In this module, we’ll keep exploring the collaboration tools available in Git. We’ll learn about tools that allow us to send changes to projects that we aren’t a member of, help us improve the quality of our code, and let us track our work better. Some of these tools will be specific to GitHub, but most of the Git repository hosting services have similar tools. So the concepts will still apply if you decide to use a different platform.</p>
<p>In recent years, GitHub has become a super popular platform for collaboration across many projects. It’s used heavily for open-source projects. These are projects that allow anyone to use, copy, and modify their code. Having the code published online means that anybody in the world can learn from what the project is doing, and even collaborate on fixes and extra features. It also helps us learn from each other, because we can look at how others have solved the problem that we’re tackling.</p>
<p>If you’re trying to learn a new technology, it’s a great idea to practice your skills by contributing to a project that uses that technology. To do that, you’ll need to know how to interact with the project. This includes how to send bug fixes, how to make sure that your fixes are applied, and even how to figure out which fixes are needed.</p>
<h3 id="a-simple-pull-request-on-github">A Simple Pull Request on GitHub</h3>
<p>As we called out, we can use GitHub to look at other people’s code and collaborate with them. Let’s see this in action by having to look at one of the projects from our colleague. Our colleague has created the project to include all validation functions. Let’s have a look at the <a href="http://validations.py">validations.py</a> file. We can see the code of a function that validates username. But, if you look closely at the functions documentation, you might notice that there’s a typo. We can improve our colleague’s code by fixing that typo, Let’s do that.</p>
<p>We’ll click on the little pencil icon which let’s us edit the file directly from the web interface. We’re trying to edit a file in a project that we don’t have a right access to. GitHub tells us it created a fork of this project for us, which we can commit our changes to. And if we submit changes to this file, it will create a new branch so that we can send a pull request. But what exactly is a fork? <strong>Forking is a way of creating a copy of the given repository so that it belongs to our user</strong>. In other words, our user will be able to push changes to the forked copy, even when we can’t push changes to the other repo.</p>
<p>When collaborating on projects hosted on GitHub, the typical workflow is, first, create a fork of the repo, and then work on that local fork. A forked repo is just like a normal repo, except Github knows which repo it forked from. So we can eventually merge our changes back into the main repo by creating a <em>pull request</em>. <strong>A pull request is a commit or series of commits that you send to the owner of the repository so that they incorporate it into their tree</strong>.</p>
<p>This is a typical way of working on GitHub, because in most projects, only a few people have commit rights to the repo. But anybody can suggest patches, bug fixes or even new features by sending pull requests that people with commit access can then apply. Typically, the owners of the repo will review the changes before merging them, checking that they match the development guidelines for the project and that the license is valid and so on. Let’s fix the typo in the file to see what the pull request looks like.</p>
<p>Once we’re done making changes to the file, we can make a change proposal, by scrolling down and filling in the description of the change. In this case, we fix the typo in the function documentation. Clicking on the Proposed file change button, we’ll create a commit in our forked repo, so that we can send the change to our colleague. Let’s do that now.</p>
<p>We’ve created a commit on our forked repo. But we haven’t yet created the pull request that will send the changes to the owner of the original repo. On this screen, we can see a lot of information about our change. We can see what repositories and branches are involved in the creation of the pull request. We can also see that GitHub automatically created a branch called <em>patch-1</em> for us. And that our change can automatically be merged, yay, no conflicts.</p>
<p>This window also lets us review the change before we create an actual pull request. Once we’re ready, we just click the <em>Create pull request button</em>. This opens a text box where we can enter comments about our change. In this case, a change is really simple, we just fixed the typo so there’s nothing extra to add. If we were suggesting a more complex change, we could use this text box to provide more context. The checkbox at the bottom lets us allow edits from maintainers. This can be useful for example, if by the time a project maintainer gets around the merging or change, there’s been more commits and our change needs rebasing. By allowing edits, the maintainer can do it themselves instead of asking us to do it, less work, yes please. Okay, we’re ready, let’s click Create pull request. Cool, we’ve created a pull request with our change. Our colleague can now look at it and decide whether they want to merge it to the project or not.</p>
<p>In this section, we checked out the simplest way of making pull requests, which is doing them directly through the GitHub interface. By using this workflow, you can already start contributing to projects on GitHub.</p>
<h3 id="the-typical-pull-request-workflow-on-github">The Typical Pull Request Workflow on GitHub</h3>
<p>In our last section, we saw how to create pull request directly on GitHub by using the web interface to edit files. This works for simple changes like fixing typos or adding documentation to a function, but it’s not so great for making larger changes that we want to preview or test. To do that, we’ll normally have a local copy of the repo in our computer and work with the forked repo as a remote. We’d need to use all the Git commands that we’ve learned up till now to do this. Let’s check out this process by creating a fork of another repo.</p>
<p>On top of the validations repo, our colleague has created a rearrange repo, and we want to help them out. We’ll go to the rearranged repo and create a fork by pressing the Fork button. It takes a few seconds to create a copy of the repo for our user. The copy will contain the current state of the repo including files and commit history. Once the fork is created, we’re shown a page that corresponds to the same repo name, but it’s under our user. See how it shows that it’s a forked repo by stating the original repo under the name.</p>
<p>All right. We’ve created a forked version of the repo on GitHub. We can now get a local copy of the repo on our computer by copying the URL and then calling the <strong>git clone</strong> command with it. We now have a new directory called rearrange with the contents of the repo. We can look at the contents by changing into that directory enlisting all files. We can look at the commit history using our old friend <strong>git log</strong>. Now that we have a local copy of the repo, we can make any changes we’d like to it. For example, this project doesn’t currently have a <a href="http://README.md">README.md</a> file. Let’s improve the documentation by creating that.</p>
<p>To do that, we’ll create a new branch called Add README. Do you remember how to create new branches? We do it by running <strong>git checkout -b add-readme</strong>. We can now start editing the <a href="http://README.md">README.md</a> file. The MD extension indicates that we’re using <em>Markdown</em>, which is a lightweight markup language. We can use it to write plain text files that are then formatted following some simple rules. In this case, we’ll start with a title with the module’s name and a brief description that says it’s used to rearrange names. Our README file is small, but it’ll do for now, let’s save it and commit it. Now, to push the change to our forked repo, we need to create the corresponding remote branch. Do you remember the command for that? Yes. It’s <strong>git push -u origin add-readme</strong>. So when we push the change to the new branch, we got a message that we can create a pull request if we want to. We’ll do that in a minute. First, let’s check out how our file looks when rendered. Yes, our README file rendered successfully. We’re ready to create a pull request for our change.</p>
<p>To do that, let’s look at the top of the Project page. GitHub tells us that our branch is ahead of the original repositories master branch by one commit, which is the commit we just made. We can start our pull requests by clicking on the <em>Pull Request link</em>. As we called out, <em>before creating a pull request, it’s always important to check that the code will merge successfully</em>. GitHub tells us that our change can be automatically merged, which is great news. If this wasn’t the case, we’d need to rebase our change against the current branch of the original repo so that it could be merged. The window is showing us the TextBox where we can enter comments about our change. As we mentioned before, we should use this to explain why we’re creating this pull request. This lets the person that will approve the change understand why they should merge the change into the main tree. Are we fixing a bug? This is a new feature to let the project support more use cases? How will the project benefit from including our change? Whatever info might be useful to the approver, record it here. We can also use this box to explain how the change was tested. <em>If the project includes automatic test infrastructure, our pull request should include a tests for our changes and we can state that all test still pass</em>. But if there’s no automatic testing, then we can use this box to explain how we tested the change manually. In this case, we’ve just added a README file that the project was missing before. So we’ll just say we’re adding a README file that was missing for the project. <em>We should also check that the change we’re sending looks correct</em>. It’s always a good idea to double-check that we’re sending the right change. To do that, let’s look at the <em>diff</em> that appears at the bottom of the page. Yes, that’s exactly what we want. All right. We’re ready. Let’s click the <em>Create Pull Request button</em>. Awesome. We’ve created our second pull request. The number next to the name of our pull request is the identifier that’s used in GitHub to track issues and pull requests. We can use this identifying number to access this pull request anytime we need it.</p>
<p><em>But why would we need to access a pull request after we send it? It’s pretty common for project maintainers to come back with questions, comments, or even ask us to fix our pull requests</em>. Imagine you’ve just finished preparing a pull request for a great new feature, and you get a comment saying that it’s missing some documentation. What would you do?</p>
<h3 id="updating-an-existing-pull-request">Updating an Existing Pull Request</h3>
<p>When we send a pull request, it’s pretty common to receive some comments from the project maintainers asking for some improvements.</p>
<p>The improvement could be to add documentation or tests, or maybe we need to make sure that change works for all cases or that it follows the project style guidelines. There’s nothing wrong with getting these comments, <em>it actually shows the project maintainers are interested in our change</em>. To get our change approved, it’s important that you address the comments. So if we’re asked to add documentation for example, we go and do it.</p>
<p>So back to our change, looks like we got a comment from one of our colleagues. We got a comment saying that our README was too short and they’d like us to add an example. To address this comment, will add more details to our file. We’ll start by explaining that the function rearranges LastName, FirstName into FirstName LastName and then we’ll add an example. We’ll say that calling rearrange name with Turing, Alan as a parameter, will return <em><strong>Alan Turing</strong></em>. We fleshed out the README file a bit. Now we can add our changes and commit them to the repo as usual. Let’s run <strong>git commit</strong> and pass a commit message saying that we’ve added more information to the README, and after that, we’ll push the change to the repo.</p>
<p>Now that we’ve pushed our change back to the repo, let’s check our pull request in GitHub. In the Commit’s tab, we can see our two commits. Our commit now shows up as a part of the same pull request. <em>It’s important to notice here that we just pushed our commit to the same branch as before and GitHub automatically added it to the pull request. If we wanted to create a separate pull request, we would need to create a new branch instead</em>.</p>
<p>If we go to the Files Change tab, we can see all files affected by the pull request, no matter which commit they were changed in. Whenever we look at the diff generated by a commit or a chain of commits, GitHub will show a color diff for the changes that we’ve made. It will use green for new lines and red for lines that were deleted. If only a part of the line changed, it will highlight that specific part of the line.</p>
<p>In this case, it’s a new file, so all the lines are additions. Check out how we see only one file even when there are two separate commits. What we’re seeing is the difference between our repo and the original repo we created the pull request for. You can also click on the preview icon and show the rendered markdown contents. Github renders our file and highlights the changes.</p>
<p><em><strong>Keep in mind that each project in GitHub may work slightly differently</strong></em>. Some projects may ask you to have only one commit in your pull requests, other projects may ask you to rebase against the latest master branch when your pull request is ready to be merged back into the main tree. Github allows projects to set their contribution guidelines. You’ll find a link to them whenever you create a new pull request or issue in a project. So make sure you’ve read these guidelines and that your pull requests match them.</p>
<p>In this section, we saw how to update our pull requests by doing new commits in our local Git repository and pushing them to the remote repository. We’d seen before how to use the Git web interface to create new pull requests and we can use this interface to update a pull request. This can be handy when the change that we want to make is small like fixing a typo or adding an extra sentence to the documentation.</p>
<h3 id="squashing-changes">Squashing Changes</h3>
<p>As we’ve caught up before, <em>you shouldn’t rewrite history when the commits have been published</em>. That’s because someone else may have already synchronized that repo with those contents. <em>This rule is waived with pull requests, since it’s usually only you who have cloned your fork of the repository</em>.</p>
<p>So say the project maintainers ask us to create a single commit that includes both changes and a more detailed description than the one we submitted. We can do that by using the interactive version of the rebase command called <strong>git rebase -i</strong>, and as the parameter to the command we will pass the master branch. So we’ll call <strong>git rebase-i master</strong>.</p>
<p>When we call an interactive rebase, a text editor opens with a list of all the selected commits from the oldest to the most recent. <em>By changing the first word of each line, we can select what we want to do with the commits</em>. The default action here is <em><strong>pick</strong></em> which takes the commits and rebases them against the branch we selected. This is what we do with git rebase in an earlier section when we called it without the -i flag. But now we can change the action to something else.</p>
<p>The comments in the file tells all the different commands we can use for our commits. For example, we can reword a commit message keeping the changes as they are but modifying the commit message. We can also edit the commit to add or remove changes from it. We have two options for combining commits, <em><strong>squash</strong></em> and <em><strong>fix up</strong></em>. In both cases, <em>the contents of the selected commit are merged into the previous commit in the list</em>. The difference is what happens with the commit messages.</p>
<ul>
<li>
<p>When we choose <em><strong>squash</strong></em>, <em>the commit messages are added together and an editor opens up to let us make any necessary changes</em>.</p>
</li>
<li>
<p>When we choose <em><strong>fix up</strong></em>, <em>the commit message for that commit is discarded</em>.</p>
</li>
</ul>
<p>For our example, we want to use squash so that we can combine both commits but also modify the commit description. So let’s change the <em>pick</em> command in the second line to <em>squash</em> it into the first one, then we’ll save and exit the editor as usual. Once we’ve told git that we want to sq_uash a commit unto the one before it, we’re given another file to edit. In this case, it’s the <em>combined commit message</em>. As usual, git shows us some helpful information in the comments including which files are modified and what commits are being combined. We want to improve the description by adding more info about our change. Let’s add we’re including an example use case. All right. Now that our commit contains the right information, we can save and exit as usual.</p>
<p>Let’s check the output of <strong>git show</strong> to see the latest commit and the changes in it. Success, we got exactly what we wanted here, our two changes have been combined into one that contains the whole new file and the right commit message.</p>
<p>Before we try to <em><strong>push</strong></em> this change to our repo, let’s call <strong>git status</strong> to check the info that git gives us about the current state. Git tells us that our local branch has one commit, which is the rebase we just did. It also tells us that the <em>origin/add-readme branch</em> has two commits. These are the two commits we had already pushed to the repo. Let’s look at the graph history of our commits by calling <strong>git log --graph --one line --all</strong> for all branches, and <strong>-4</strong> for just the latest four commits. We can see that the two commits pushed to the origin/add-readme branch show up in a different path than the commit that’s currently in our local add-readme branch. <em>This is expected whenever we do a rebase because the old commits are in the remote repo and we have a different commit in our local repo</em>. What do you think will happen when we call git push? Let’s try that out.</p>
<p>As we expected, git doesn’t like us trying to push our change because it can’t be fast-forwarded. But in this case, we don’t want to create a merge. Instead, we want to replace the old commits with the new one. To do this, we will call <strong>git push -f</strong> to force git to push the current snapshot into the repo as is. This time, our push completed successfully. Git tells us here that we forced an update.Let’s look once again our history graph by running <strong>git log – graph --one line --all -4</strong>. This time, it’s just one commit on top of master. The divergence is gone. Now let’s look at the contents of the pull request. Success. We’ve managed to combine both are commits into one by using the interactive version of git rebase. You now know how to create a pull request on GitHub, how to update a pull request, and squash changes. These tools are all super-helpful when using GitHub.</p>
<h3 id="git-fork-and-pull-request-cheat-sheet">Git Fork and Pull Request Cheat-Sheet</h3>
<p>Check out the following link for more information:</p>
<ul>
<li><a href="https://help.github.com/en/articles/about-pull-request-merges">https://help.github.com/en/articles/about-pull-request-merges</a></li>
</ul>
<h2 id="code-reviews">Code Reviews</h2>
<h3 id="what-are-code-reviews">What are code reviews?</h3>
<p>GitHub and other repository hosting services offer tools for doing <em><strong>code reviews</strong></em> on their platform. And while this is called <em>code reviews</em>, we can actually use the same tool and process to do reviews of any text file including <strong>configuration</strong> and <strong>documentation</strong>.</p>
<p><strong>Doing a code review means going through someone else’s code, documentation or configuration and checking that it all makes sense and follows the expected patterns</strong>.</p>
<p>The goal of a <em>code review</em> is to improve the project by making sure that changes are high quality. It also helps us make sure that the contents are easy to understand, that the style is consistent with the overall project, and that we don’t forget any important cases.</p>
<ul>
<li>
<p>Reviews increase the number of eyes that have checked the code. This increases the code quality and reduces the amount of bugs. It doesn’t mean that there’ll be no bugs, but at least the most obvious bugs will be caught.</p>
</li>
<li>
<p>Also, this helps spread knowledge since both the code writers and the code reviewers now know what the code is doing. When we work in the same office as our teammates, we can do reviews in person by looking together at the changes and discussing how the contents fit together. But when the person that we’re working with is in a different office or time zone We’re better off using a code review tool. Code review tools let us comment on someone else’s code. These let us leave feedback on <em>how they could make their code better</em>.</p>
</li>
<li>
<p>Common code issues are unclear names that makes the code hard to understand,</p>
</li>
<li>
<p>Forgetting to add a test, or forgetting to handle a specific condition.</p>
</li>
<li>
<p>If we’re writing documentation, our reviewer can help us catch typos and things that aren’t totally clear.</p>
</li>
</ul>
<p>On platforms like Github, it’s common for projects to only requires reviews for people that don’t have commit access while the project maintainers can commit directly. But doing code reviews improves the code’s overall quality. Today, some open source projects and lots of companies require code reviews for everybody. This isn’t because they don’t trust them, but because they want the highest quality code. And code reviews are how they get there.</p>
<p>O<strong>ne thing to always remember, code reviews are not about us being good or bad coders, they’re about making our code better</strong>. <em>And not only that specific review, but in general</em>. By getting feedback, we can keep improving our code techniques. And by reviewing other people’s code, we can also learn new and different ways of achieving results.</p>
<p>Like everybody else after toiling for hours on a problem and finally solving it, all I want to do is submit my code and be done with it. But this rarely happens. Code reviews usually send me back to the drawing board with small errors and nitpicks, but that’s a good thing. These code reviews point out things that we might have missed along the way and ensure that our code makes sense to others.</p>
<h3 id="the-code-review-workflow">The Code Review Workflow</h3>
<p>In our last section, we explained what code reviews are and how they can make our code better. Now, we’ll check out a typical code review using a reviewing tool.</p>
<p>Imagine we’ve just finished a bunch of code changes, now, we’ll ask a reviewer to look at our code. The reviewer might say that everything is okay and our changes approved, but usually they’ll find something that needs improving. So they’ll add comments to our changes explaining what needs to be fixed and how. When we get the review comments will address them by fixing our typos, adding any missing tests and so on. After addressing a comment, we can mark it as resolved so that we know it’s been taken care of. If there’s something that we aren’t sure how to do or we think a different approach might be better, we can reply to the comment and ask our reviewer for more information without marking the comment as resolved. Once all comments have been resolved and our viewer is satisfied with the results, they’ll approve the change and we’ll be able to merge it.</p>
<p>You may be wondering, what are all of these comments that I receive? There’s a wide range of things your reviewer might have to say about your code.</p>
<ul>
<li>
<p>Sometimes, you might have forgotten to take into account something important and you’ll need to do significant work to fix it.</p>
</li>
<li>
<p>Sometimes, your reviewer might point out something small, that’s not really critical. And the comment is mostly a suggestion for making the code better. These comments are usually prefixed, saying that it’s a <em><strong>Nit</strong></em>.</p>
</li>
</ul>
<p>Whatever it is, it’s important that you take the time to understand what the comment is and what you need to do to address it.</p>
<p>For example, if you’ve written a piece of code and your reviewer asks you to explain why or how the code is doing something, it might be tempting to just answer their question in the comment and mark it as resolved.</p>
<p>But this isn’t a great idea, because only the reviewer gets to see your answer. Instead, it’s better to take this as an opportunity to make the code clearer. For example, you could do this by using better variable names or splitting a large piece of code into smaller functions. On top of that, you can add comments to the code and documentation to your functions to make sure that the how and why are clearly explained. It’s common for code reviews to include several comments about the style of the code.</p>
<p>To avoid a lot of back and forth, it’s a good idea to refer to a style guide that explains the preferred coding style for the project. For example, lots of Python projects, use the <em><strong>PEP8</strong></em> style guide. If the project you’re contributing to doesn’t include a style guide, make sure that you ask for one.</p>
<p>There are a bunch of code reviewing systems out there. And while they all follow the same patterns, they don’t all work exactly the same way. In some code reviewing tools, you’ll need one of the project maintainers to approve your code before it’s submitted. In other tools, you’ll just need to get a couple +1s from contributors to the project before you can submit. The goal is to always ensure that your code has been reviewed by people who are familiar with the project, so that it’s ready to be submitted. Can you think of a project you’ve worked on in the past where code reviews could have been helpful? Maybe you worked as a part of a team and had trouble making sure that everyone agreed on how things should be done. Or maybe you were learning how to use a new tool and you would have benefited from a second pair of eyes on your work. No matter how simple or complex a project is, it can always be improved with good code reviews.</p>
<h3 id="how-to-use-code-reviews-in-github">How to Use Code Reviews in GitHub</h3>
<p>Up till now, we’ve talked about the general process of doing code reviews. This process applies to any platform with code reviewing tools. Now, let’s check out how this process looks on GitHub, specifically. Remember, a while back in this module, we created a pull request that added a read me file. Conveniently, our colleague just replied with a few comments. Let’s have a look.</p>
<p>The code review has one overall comment, and line by line, comments, highlighting the things that we need to get done. We can view all changes requested for the file we created by clicking on the view changes button. Our reviewer made three comments about our file. The first one is asking us to add a period at the end of the sentence. The second one asks us to add another hashtag which will make the title render and a smaller font. The last one will require a bit more work since it’s asking us to include a couple more examples. Let’s fix these. We’ll add a period at the end of the second sentence, and then add a second hashtag before the example title, and finally, add a few more examples. To do that, we’ll use the star character, which is another feature of the Markdown language that lets us easily create bullet points. So we’ll add a couple of more lines with the same format, and say that Hopper, Grace M. turns into Grace M. Hopper, and that Voltaire stays as Voltaire. All right. We’ve addressed all the comments in our code review. Let’s save our file and then commit the changes.</p>
<p>Since we want this change to be a part of the previous commit, we’ll call <strong>git commit -a</strong> with the <strong>–amend</strong> flag, which will edit the original commit. Once we’ve done that, let’s call <strong>git status</strong> to see what Git has to say about our repo Just like before, we see that our change has diverged from the origin slash master branch. You might remember that <strong>git commit --amend</strong> modifies commits. <em>So it’s not safe to do with commits that have been pushed to the repo</em>. Using amend is pretty much the same as creating a new commit, and then using an interactive rebase to fix up a change. So, the commit gets replaced by a completely new commit with a completely different commit ID. This means that to push it, we’ll need to use the -f flag again. <em>Remember that forcing pushes is fine for pull request branches because nobody else should have cloned it</em>. But <strong>this isn’t something that we want to do with public repos</strong>.</p>
<p>All right. We’ve done what our colleague asked. Let’s now go back to look at the pull request and resolve the comments. See that comment that says outdated, that’s because we’ve pushed a new version since we’ve made the change. But, since we’ve taken care of their request, we can ignore the outdated comment and just resolve the conversation. Cool, we’ve addressed all the comments. We can leave a message in our conversation to let our reviewer know that we’ve resolved all the comments and ask them to take another look. Our reviewer can now check out the new changes and approve them if they’re satisfied. As with lots of other topics we’ve covered, making the most out of the code review process will require some practice. It’s great to have some tips but in the end we need to learn by experience. So don’t be afraid to practice practice practice.</p>
<h3 id="more-information-on-code-reviews">More Information on Code Reviews</h3>
<p>Check out the following links for more information:</p>
<ul>
<li>
<p><a href="http://google.github.io/styleguide/">http://google.github.io/styleguide/</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/articles/about-pull-request-reviews">https://help.github.com/en/articles/about-pull-request-reviews</a></p>
</li>
<li>
<p><a href="https://medium.com/osedea/the-perfect-code-review-process-845e6ba5c31">https://medium.com/osedea/the-perfect-code-review-process-845e6ba5c31</a></p>
</li>
<li>
<p><a href="https://smartbear.com/learn/code-review/what-is-code-review/">https://smartbear.com/learn/code-review/what-is-code-review/</a></p>
</li>
</ul>
<h2 id="managing-projects">Managing Projects</h2>
<h3 id="managing-collaboration">Managing Collaboration</h3>
<p>Over the past few sections, we’ve looked at how we can collaborate with others using tools provided by platforms like <em>GitHub</em>. These tools can be very helpful but some coordination outside of the platform is <em><strong>always</strong></em> going to be needed.</p>
<p>For example, the project you’re working on might need up medium or large refactor that will affect multiple lines of code across several files. It’s important to give your colleagues the heads up that this refactor is coming. <em>If possible, try to do the refactor while the other developers are working on a different part of the project because this helps avoid large and complicated conflicts</em>.</p>
<p>We’ve called on a bunch of times that <em><strong>documenting</strong></em> your work is super important. When working together with a large group of people, documenting what you do and why you do it becomes even more important otherwise you’ll spend most of your time answering everybody else questions. Also, say there’s a problem with your service while you’re on vacation or the person who developed the code is on the other side of the world and currently sleeping. In these situations, the documentation needs to be good enough to help someone else fix the problem. The most basic form of this is <em>writing clear code</em> with <em>good comments and documentation for those functions</em> in the code. On top of that, you’ll want to create documentation files to let others know how they can interact with your project like the <a href="http://readme.md">readme.md</a> file that we created an earlier section.</p>
<p><em><strong>If you’re a project maintainer, it’s important that you are reply promptly to pull requests and don’t let them stagnate</strong></em>. The more time that passes until a pull request gets reviewed, the more likely it is that there’s a new commit that causes a conflict when you try to merge in the change. On top of this, if the person contributing the changes of volunteer that’s just trying to help, they may lose their motivation to work on the project if you make them wait too long for feedback.</p>
<p>Another thing to remember when you maintain a project especially if it’s an open source project that volunteers are contributing to is that <strong>it’s important that you understand any changes you accept</strong>. You never know if the other person is going to stick around to maintain the code after you merge it in so you better make sure you can do that. <em>You should also be careful with which patches you accept or reject</em>.</p>
<ul>
<li>
<p>Accepting everything that gets sent your way might make your project grow too much and become unmanageable or it might take into account too many corner cases and cause complicated code that’s hard to maintain.</p>
</li>
<li>
<p>On the flip side, if you don’t accept any pull requests you’ll discourage contributors and miss out on keeping your project active and relevant.</p>
</li>
</ul>
<p>We’ve talked about <em><strong>style guides</strong></em> a few times already. If you’re contributing to a project, you want to check out the style guide and make sure you follow it. If you own a project, it makes sense to create a style guide so that others know what you’re expecting from them.</p>
<p><em>When it comes to coordinating who does what and when, a common strategy for active software projects is to use an <strong>issue tracker</strong></em>. This is a super useful tool and we’ll find out more about it in the next section.</p>
<p>On top of that, when the project is large enough, <em>it’s important to have another way of communicating and coordinating between contributors</em>. For many years, most projects used <em>mailing list and IRC channels</em> for communication. Recently, new forms of communicating have gained popularity like Slack channels or Telegram groups. If you’re managing your own project, choose whatever communication medium best fits your needs and those of your contributors. If you’re collaborating with a project you don’t own, you’ll want to find out what channels are being used for collaboration and with that you now have a rough idea of how to collaborate with others across the internet.</p>
<h3 id="tracking-issues">Tracking Issues</h3>
<p>Deciding who’s going to do what is critical when collaborating with others, with no coordination, two or more people might spend time working on the same part of a project while nobody works on the other critical parts.</p>
<p>Imagine that you and your colleagues decided that you’d work on building automation software, for keeping the computers on your network up to date. But then instead of dividing the task into smaller pieces and assigning them to different people, you just randomly started working on some part of the infrastructure. The result would probably be total chaos, with different pieces of software that won’t work well together, and lots of gaps that nobody worked on.</p>
<p>For small teams, it’s usually easy enough to discuss in person who’s going to be working on what. But as soon as the group starts growing, talking about responsibilities and what to do next becomes more of a hassle. That’s when a tool like an <em><strong>issue tracker</strong></em> or bug tracker can help us coordinate our work better.</p>
<p>An <em><strong>issue tracker</strong></em> tells us the tasks that need to be done, the state they’re in and who’s working on them. The system also let’s us <em>add comments to the issue</em>, these comments can be super helpful. They can give us more details about the problem, explain a way to solve it, or detail how to test if it’s been solved.</p>
<p>Issue trackers aren’t just useful for people actively working on projects. They also let users report bugs when they come across them, even if they don’t know how to solve the problem. Sometimes users come across problems that we never even thought possible. And having them report these issues through a bug tracker can help make our projects better. And the tracker can also help volunteers that want to start contributing to the project.<br>
Having a clear visible list of the pending work, lets new contributors figure out how to help and where to jump in.</p>
<p>There are a bunch of different solutions to track bugs or issues. There’s a popular bug tracker called <em><strong>Bugzilla</strong></em>, which is used by quite a few open source projects. On the flip side, platforms like <em><strong>GitHub</strong></em> have an issue tracker baked in. So, if you’re hosting your project there, it can be very handy to track work on your project, like the <em>problems to solve</em>, the <em>features to add</em> and the <em>use cases to include</em> in it…</p>
<p>There’s a bunch more to learn about tracking issues, but this should be enough to get you started. Feel free to experiment on your own and try more ways to interact with the system.</p>
<h3 id="continuous-integration">Continuous Integration</h3>
<p>Throughout this course, we’ve been making changes to our files, sometimes we ran them manually to test if they still worked after the change, sometimes we just forgot to do that. This is common for any software project no matter how big or small.</p>
<p>As humans, we’re not great at remembering to do lots of stuff so we can’t rely on people remembering to test their code, not even ourselves. Luckily, we don’t need to. We can write automated tests to test the code for us and then use a <em><strong>continuous integration or CI system</strong></em> to run those tests automatically.</p>
<p><em><strong>A continuous integration system will build and test our code every time there’s a change</strong></em>. This means that it will run whenever there’s a new commit in the main branch of our code. It will also run for any changes that come in through pull request. In other words, if we have continuous integration configured for our project, we can automatically run our tests using the code in a pull request. This way, we can verify that the test will pass after the new changes get merged back into the tree and that means instead of hoping our collaborators will remember to properly test their code, we can rely on our automated testing system to do it for us.</p>
<p>Once we have our code automatically built and tested, the next automation step is continuous deployment which is sometimes called <em><strong>continuous delivery or CD</strong></em>.</p>
<p><em><strong>Continuous deployment means the new code is deployed often</strong></em>. <em>The goal is to avoid roll outs with a lot of changes between two versions of a project and instead do incremental updates with only a few changes at a time</em>. This allows errors to be caught and fixed early. Typical configurations include deploying a new version whenever a commit is merged into the main tree or whenever a branch is tagged for release.</p>
<p>There’s a large world of tools and platforms related to CI/CD which is what the whole system is usually called. One popular option is <em><strong>Jenkins</strong></em> which can be used to automate lots of different types of projects. Some repository hosting services like <em><strong>GitLab</strong></em> provide their own infrastructure for doing continuous integration. GitHub doesn’t offer an integrated solution. Instead, the popular alternative is to use <em><strong>Travis</strong></em> which communicates with GitHub and can access the information from GitHub projects to know which integrations to run.</p>
<p>No matter which tool you use, there are a bunch of concepts that you’ll need to deal with when creating your own CI/CD.</p>
<ul>
<li>
<p>The first one is a concept of pipelines. <em><strong>Pipelines specify the steps that need to run to get the result you want</strong></em>. For a simple Python Project, the pipeline could be to just run the automated tests. For a web service written in Go, the pipeline could be compile the program, run the unit tests and integration tests and finally deploy the code to a test instance.</p>
</li>
<li>
<p>Another concept that turns up when doing CI/CD is <em><strong>artifacts</strong></em>. <em><strong>This is the name used to describe any files that are generated as part of the pipeline</strong></em>. This typically includes the compiled versions of the code but can include other generated files like PDFs for the documentation or <em>OS specific packages for easy installation</em>. On top of this, you might want to keep the <em>logs of the pipelines build and test stages to review if things fail</em>.</p>
</li>
</ul>
<p><em><strong>- When setting up CICD, we have to be careful about how we manage secrets.</strong></em> If our pipeline includes deploying a new version of the software to a test server, we need to somehow give the software that’s running the pipeline access to our test server. There are a bunch of different strategies to do this, like <em>exchanging SSH keys</em> or <em>using application specific API tokens</em>. For some pipelines, it might be unavoidable to use one of these methods but be aware that you’re giving access to your test servers to the owner of the service that’s running the pipeline for you. It’s a bit like giving your house keys to the person checking your heating once a year.</p>
<p>So two things to remember:</p>
<ol>
<li>
<p><em><strong>Make sure the authorized entities for the test servers are not the same entities authorized to deploy on the production servers</strong></em>. That way, if there’s any kind of compromise in the pipeline, your production server is not affected.</p>
</li>
<li>
<p>Second, <em><strong>always have a plan to recover your access in case your pipeline gets compromised</strong></em>. If you want to set up Travis for your GitHub project, you can do that by logging into the <a href="https://www.travis-ci.com">Travis website</a> using your GitHub account then enable the projects that you want to continuously integrate. After that, you’ll need to add a configuration file to your project written in <em>YAML format</em> that states the language your project is in, in which steps to take for the pipeline. This file can be very simple if your project files are typical configuration for the language you’re using but can also become very complex if you want to run a complicated pipeline with lots of stages and steps outside the defaults. We won’t go into a ton of detail here but there’s more info out there. Feel free to investigate on your own if you want to continuously integrate and deliver your project.</p>
</li>
</ol>
<h3 id="additional-tools">Additional Tools</h3>
<p>Check out the following links for more information:</p>
<ul>
<li>
<p><a href="https://arp242.net/diy.html">https://arp242.net/diy.html</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/articles/closing-issues-using-keywords">https://help.github.com/en/articles/closing-issues-using-keywords</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/articles/setting-guidelines-for-repository-contributors">https://help.github.com/en/articles/setting-guidelines-for-repository-contributors</a></p>
</li>
<li>
<p><a href="https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.html">https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.html</a></p>
</li>
<li>
<p><a href="https://stackify.com/what-is-cicd-whats-important-and-how-to-get-it-right/">https://stackify.com/what-is-cicd-whats-important-and-how-to-get-it-right/</a></p>
</li>
<li>
<p><a href="https://docs.travis-ci.com/user/tutorial/">https://docs.travis-ci.com/user/tutorial/</a></p>
</li>
<li>
<p><a href="https://docs.travis-ci.com/user/build-stages/">https://docs.travis-ci.com/user/build-stages/</a></p>
</li>
</ul>
<h3 id="module-4-collaboration---wrap-up">Module 4: Collaboration - Wrap Up</h3>
<p>Yes, you made it to the end of the last module. No, seriously, congrats on making it all the way here. Wow, we’ve learned so much over the last few videos:</p>
<ul>
<li>
<p>We’ve checked out a lot of tools for better collaboration through GitHub,</p>
</li>
<li>
<p>We looked at the typical workflow for pull requests, how to update and squash changes,</p>
</li>
<li>
<p>We learned how code reviews make our code better by helping us catch bugs, typos and other problems,</p>
</li>
<li>
<p>Finally, we looked into some advanced tools for collaboration, like issue trackers or continuous integration services.</p>
</li>
</ul>
<p>All these builds on the other tools and techniques for version control that we’ve covered through out the course, like checking the change history, rolling back a bad change, and merging other people’s changes. You’ve learned a lot over this course and you should be really proud of what you’ve achieved.</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>

    </div>
  </div>
</body>

</html>
